# 反射与动态代理

## 📌 学习目标

- 理解反射的概念和原理
- 掌握Class类的使用
- 熟练使用反射API
- 理解动态代理机制
- 掌握JDK动态代理和CGLIB

## ⭐ 核心概念

- **Class对象** ⭐⭐⭐⭐⭐
- **反射API** ⭐⭐⭐⭐⭐
- **JDK动态代理** ⭐⭐⭐⭐⭐
- **CGLIB代理** ⭐⭐⭐⭐⭐
- **应用场景** ⭐⭐⭐⭐⭐

## 1. 反射基础 ⭐⭐⭐⭐⭐

### 什么是反射？

反射（Reflection）是Java的一种**运行时机制**，允许程序在运行时：
1. **检查类的结构** - 获取类的字段、方法、构造器
2. **创建对象** - 动态创建类的实例
3. **调用方法** - 动态调用对象的方法
4. **访问字段** - 动态读写对象的字段

**应用场景**：
- **框架开发** - Spring IoC、MyBatis
- **序列化/反序列化** - JSON、XML
- **动态代理** - AOP
- **注解处理** - 运行时处理注解

### 获取Class对象 ⭐⭐⭐⭐⭐

```java
public class User {
    private String name;
    private int age;
    
    public User() {}
    
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public void sayHello() {
        System.out.println("Hello, I'm " + name);
    }
}

public class ReflectionDemo {
    public static void main(String[] args) throws Exception {
        // 方式1：通过类名.class ⭐⭐⭐⭐⭐
        Class<User> clazz1 = User.class;
        
        // 方式2：通过对象.getClass() ⭐⭐⭐⭐⭐
        User user = new User();
        Class<?> clazz2 = user.getClass();
        
        // 方式3：通过Class.forName() ⭐⭐⭐⭐⭐
        Class<?> clazz3 = Class.forName("com.example.User");
        
        // 三种方式获取的是同一个Class对象
        System.out.println(clazz1 == clazz2);  // true
        System.out.println(clazz2 == clazz3);  // true
        
        // 获取类信息
        System.out.println("类名：" + clazz1.getName());
        System.out.println("简单类名：" + clazz1.getSimpleName());
        System.out.println("包名：" + clazz1.getPackage().getName());
    }
}
```

## 2. 反射操作构造器 ⭐⭐⭐⭐⭐

```java
import java.lang.reflect.Constructor;

public class ConstructorDemo {
    public static void main(String[] args) throws Exception {
        Class<User> clazz = User.class;
        
        // 获取所有public构造器 ⭐⭐⭐⭐⭐
        Constructor<?>[] constructors = clazz.getConstructors();
        for (Constructor<?> constructor : constructors) {
            System.out.println(constructor);
        }
        
        // 获取所有构造器（包括private）
        Constructor<?>[] allConstructors = clazz.getDeclaredConstructors();
        
        // 获取无参构造器 ⭐⭐⭐⭐⭐
        Constructor<User> constructor1 = clazz.getConstructor();
        User user1 = constructor1.newInstance();
        
        // 获取有参构造器 ⭐⭐⭐⭐⭐
        Constructor<User> constructor2 = clazz.getConstructor(String.class, int.class);
        User user2 = constructor2.newInstance("Alice", 25);
        
        // 简化方式（推荐）⭐⭐⭐⭐⭐
        User user3 = clazz.getDeclaredConstructor().newInstance();
    }
}

// 私有构造器示例
public class Singleton {
    private static Singleton instance = new Singleton();
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        return instance;
    }
}

// 通过反射破坏单例
public class BreakSingleton {
    public static void main(String[] args) throws Exception {
        Singleton s1 = Singleton.getInstance();
        
        // 获取私有构造器
        Constructor<Singleton> constructor = Singleton.class.getDeclaredConstructor();
        constructor.setAccessible(true);  // 破坏访问权限 ⭐⭐⭐⭐⭐
        Singleton s2 = constructor.newInstance();
        
        System.out.println(s1 == s2);  // false，单例被破坏
    }
}
```

## 3. 反射操作字段 ⭐⭐⭐⭐⭐

```java
import java.lang.reflect.Field;

public class FieldDemo {
    public static void main(String[] args) throws Exception {
        Class<User> clazz = User.class;
        User user = new User("Bob", 30);
        
        // 获取所有public字段
        Field[] fields = clazz.getFields();
        
        // 获取所有字段（包括private）⭐⭐⭐⭐⭐
        Field[] allFields = clazz.getDeclaredFields();
        for (Field field : allFields) {
            System.out.println(field.getName() + " : " + field.getType());
        }
        
        // 获取指定字段 ⭐⭐⭐⭐⭐
        Field nameField = clazz.getDeclaredField("name");
        nameField.setAccessible(true);  // 访问私有字段
        
        // 读取字段值 ⭐⭐⭐⭐⭐
        String name = (String) nameField.get(user);
        System.out.println("name = " + name);  // Bob
        
        // 修改字段值 ⭐⭐⭐⭐⭐
        nameField.set(user, "Charlie");
        System.out.println("修改后：" + user.getName());  // Charlie
        
        // 获取字段修饰符
        int modifiers = nameField.getModifiers();
        System.out.println("是否private：" + java.lang.reflect.Modifier.isPrivate(modifiers));
    }
}

// 实用工具：对象复制
public class BeanUtils {
    public static void copyProperties(Object source, Object target) throws Exception {
        Class<?> sourceClass = source.getClass();
        Class<?> targetClass = target.getClass();
        
        Field[] fields = sourceClass.getDeclaredFields();
        for (Field field : fields) {
            field.setAccessible(true);
            
            try {
                Field targetField = targetClass.getDeclaredField(field.getName());
                targetField.setAccessible(true);
                
                Object value = field.get(source);
                targetField.set(target, value);
            } catch (NoSuchFieldException e) {
                // 目标对象没有该字段，跳过
            }
        }
    }
}
```

## 4. 反射操作方法 ⭐⭐⭐⭐⭐

```java
import java.lang.reflect.Method;

public class MethodDemo {
    public static void main(String[] args) throws Exception {
        Class<User> clazz = User.class;
        User user = new User("David", 28);
        
        // 获取所有public方法（包括继承的）⭐⭐⭐⭐⭐
        Method[] methods = clazz.getMethods();
        
        // 获取所有方法（包括private，不包括继承的）
        Method[] allMethods = clazz.getDeclaredMethods();
        
        for (Method method : allMethods) {
            System.out.println(method.getName());
        }
        
        // 获取指定方法 ⭐⭐⭐⭐⭐
        Method sayHelloMethod = clazz.getMethod("sayHello");
        
        // 调用方法 ⭐⭐⭐⭐⭐
        sayHelloMethod.invoke(user);  // Hello, I'm David
        
        // 获取带参数的方法
        Method setNameMethod = clazz.getMethod("setName", String.class);
        setNameMethod.invoke(user, "Eve");
        
        // 获取方法返回值
        Method getNameMethod = clazz.getMethod("getName");
        String name = (String) getNameMethod.invoke(user);
        System.out.println("name = " + name);  // Eve
        
        // 调用私有方法
        Method privateMethod = clazz.getDeclaredMethod("privateMethod");
        privateMethod.setAccessible(true);
        privateMethod.invoke(user);
    }
}

// 实用工具：方法调用工具
public class MethodInvoker {
    public static Object invoke(Object obj, String methodName, Object... args) 
            throws Exception {
        Class<?> clazz = obj.getClass();
        
        // 获取参数类型
        Class<?>[] paramTypes = new Class[args.length];
        for (int i = 0; i < args.length; i++) {
            paramTypes[i] = args[i].getClass();
        }
        
        // 获取方法
        Method method = clazz.getMethod(methodName, paramTypes);
        
        // 调用方法
        return method.invoke(obj, args);
    }
}
```

## 5. JDK动态代理 ⭐⭐⭐⭐⭐

### 什么是动态代理？

动态代理是在**运行时动态生成代理类**，用于：
1. **AOP** - 面向切面编程
2. **日志记录** - 方法调用日志
3. **性能监控** - 方法执行时间
4. **权限控制** - 方法访问权限

### JDK动态代理实现 ⭐⭐⭐⭐⭐

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

// 1. 定义接口（JDK动态代理必须基于接口）⭐⭐⭐⭐⭐
public interface UserService {
    void save(User user);
    User findById(Long id);
    void delete(Long id);
}

// 2. 实现类
public class UserServiceImpl implements UserService {
    @Override
    public void save(User user) {
        System.out.println("保存用户：" + user.getName());
    }
    
    @Override
    public User findById(Long id) {
        System.out.println("查询用户：" + id);
        return new User("User" + id, 25);
    }
    
    @Override
    public void delete(Long id) {
        System.out.println("删除用户：" + id);
    }
}

// 3. 创建InvocationHandler ⭐⭐⭐⭐⭐
public class LogInvocationHandler implements InvocationHandler {
    private Object target;  // 被代理对象
    
    public LogInvocationHandler(Object target) {
        this.target = target;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 前置增强
        System.out.println("=== 方法调用开始 ===");
        System.out.println("方法名：" + method.getName());
        System.out.println("参数：" + Arrays.toString(args));
        long startTime = System.currentTimeMillis();
        
        // 调用目标方法
        Object result = method.invoke(target, args);
        
        // 后置增强
        long endTime = System.currentTimeMillis();
        System.out.println("执行时间：" + (endTime - startTime) + "ms");
        System.out.println("返回值：" + result);
        System.out.println("=== 方法调用结束 ===\n");
        
        return result;
    }
}

// 4. 创建代理对象 ⭐⭐⭐⭐⭐
public class ProxyDemo {
    public static void main(String[] args) {
        // 创建目标对象
        UserService target = new UserServiceImpl();
        
        // 创建代理对象
        UserService proxy = (UserService) Proxy.newProxyInstance(
            target.getClass().getClassLoader(),  // 类加载器
            target.getClass().getInterfaces(),   // 接口数组
            new LogInvocationHandler(target)     // InvocationHandler
        );
        
        // 使用代理对象
        proxy.save(new User("Alice", 25));
        User user = proxy.findById(1L);
        proxy.delete(1L);
    }
}
```

### 代理工厂模式 ⭐⭐⭐⭐⭐

```java
public class ProxyFactory {
    
    public static <T> T createProxy(T target) {
        return (T) Proxy.newProxyInstance(
            target.getClass().getClassLoader(),
            target.getClass().getInterfaces(),
            new LogInvocationHandler(target)
        );
    }
    
    // 使用
    public static void main(String[] args) {
        UserService userService = new UserServiceImpl();
        UserService proxy = ProxyFactory.createProxy(userService);
        proxy.save(new User("Bob", 30));
    }
}
```

## 6. CGLIB动态代理 ⭐⭐⭐⭐⭐

### CGLIB vs JDK动态代理

| 特性 | JDK动态代理 | CGLIB |
|------|------------|-------|
| 实现方式 | 基于接口 ⭐⭐⭐⭐⭐ | 基于继承 ⭐⭐⭐⭐⭐ |
| 要求 | 必须有接口 | 不能是final类 |
| 性能 | 较慢 | 较快 |
| 使用场景 | Spring AOP（有接口） | Spring AOP（无接口） |

### CGLIB实现 ⭐⭐⭐⭐⭐

```java
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

// 1. 目标类（不需要接口）
public class UserService {
    public void save(User user) {
        System.out.println("保存用户：" + user.getName());
    }
    
    public User findById(Long id) {
        System.out.println("查询用户：" + id);
        return new User("User" + id, 25);
    }
}

// 2. 创建MethodInterceptor ⭐⭐⭐⭐⭐
public class LogMethodInterceptor implements MethodInterceptor {
    
    @Override
    public Object intercept(Object obj, Method method, Object[] args, 
                          MethodProxy proxy) throws Throwable {
        // 前置增强
        System.out.println("=== CGLIB代理开始 ===");
        System.out.println("方法名：" + method.getName());
        
        // 调用目标方法
        Object result = proxy.invokeSuper(obj, args);
        
        // 后置增强
        System.out.println("=== CGLIB代理结束 ===\n");
        
        return result;
    }
}

// 3. 创建代理对象 ⭐⭐⭐⭐⭐
public class CglibProxyDemo {
    public static void main(String[] args) {
        // 创建Enhancer对象
        Enhancer enhancer = new Enhancer();
        
        // 设置父类
        enhancer.setSuperclass(UserService.class);
        
        // 设置回调
        enhancer.setCallback(new LogMethodInterceptor());
        
        // 创建代理对象
        UserService proxy = (UserService) enhancer.create();
        
        // 使用代理对象
        proxy.save(new User("Charlie", 28));
        proxy.findById(1L);
    }
}
```

## 7. 实战应用 ⭐⭐⭐⭐⭐

### 1. 简易ORM框架

```java
public class SimpleORM {
    
    // 将ResultSet转换为对象
    public static <T> T resultSetToObject(ResultSet rs, Class<T> clazz) 
            throws Exception {
        T obj = clazz.getDeclaredConstructor().newInstance();
        
        Field[] fields = clazz.getDeclaredFields();
        for (Field field : fields) {
            field.setAccessible(true);
            String columnName = field.getName();
            Object value = rs.getObject(columnName);
            field.set(obj, value);
        }
        
        return obj;
    }
    
    // 将对象转换为SQL
    public static String objectToInsertSQL(Object obj) throws Exception {
        Class<?> clazz = obj.getClass();
        String tableName = clazz.getSimpleName().toLowerCase();
        
        StringBuilder columns = new StringBuilder();
        StringBuilder values = new StringBuilder();
        
        Field[] fields = clazz.getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            fields[i].setAccessible(true);
            
            if (i > 0) {
                columns.append(", ");
                values.append(", ");
            }
            
            columns.append(fields[i].getName());
            Object value = fields[i].get(obj);
            values.append("'").append(value).append("'");
        }
        
        return String.format("INSERT INTO %s (%s) VALUES (%s)", 
                           tableName, columns, values);
    }
}
```

### 2. 性能监控代理

```java
public class PerformanceMonitor implements InvocationHandler {
    private Object target;
    
    public PerformanceMonitor(Object target) {
        this.target = target;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) 
            throws Throwable {
        long startTime = System.nanoTime();
        
        Object result = method.invoke(target, args);
        
        long endTime = System.nanoTime();
        long duration = (endTime - startTime) / 1_000_000;  // 转换为毫秒
        
        if (duration > 100) {  // 超过100ms记录
            System.out.println(String.format(
                "慢方法警告：%s.%s 执行时间：%dms",
                target.getClass().getSimpleName(),
                method.getName(),
                duration
            ));
        }
        
        return result;
    }
}
```

### 3. 事务代理

```java
public class TransactionProxy implements InvocationHandler {
    private Object target;
    
    public TransactionProxy(Object target) {
        this.target = target;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) 
            throws Throwable {
        // 检查是否有@Transactional注解
        if (method.isAnnotationPresent(Transactional.class)) {
            System.out.println("开启事务");
            try {
                Object result = method.invoke(target, args);
                System.out.println("提交事务");
                return result;
            } catch (Exception e) {
                System.out.println("回滚事务");
                throw e;
            }
        } else {
            return method.invoke(target, args);
        }
    }
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@interface Transactional {
}
```

## 💡 最佳实践 ⭐⭐⭐⭐⭐

### 1. 反射性能优化

```java
// 缓存Class对象和Method对象
public class ReflectionCache {
    private static final Map<String, Class<?>> classCache = new ConcurrentHashMap<>();
    private static final Map<String, Method> methodCache = new ConcurrentHashMap<>();
    
    public static Class<?> getClass(String className) throws ClassNotFoundException {
        return classCache.computeIfAbsent(className, k -> {
            try {
                return Class.forName(k);
            } catch (ClassNotFoundException e) {
                throw new RuntimeException(e);
            }
        });
    }
}
```

### 2. 安全使用反射

```java
// 检查权限
SecurityManager sm = System.getSecurityManager();
if (sm != null) {
    sm.checkPermission(new ReflectPermission("suppressAccessChecks"));
}

// 使用try-finally确保恢复访问权限
Field field = clazz.getDeclaredField("name");
boolean accessible = field.isAccessible();
try {
    field.setAccessible(true);
    // 操作字段
} finally {
    field.setAccessible(accessible);
}
```

## 🎯 实战练习

1. 实现一个简单的依赖注入容器
2. 创建一个通用的DAO层
3. 实现方法调用日志记录
4. 编写一个对象验证框架

## 📚 下一步

学习完反射与动态代理后，继续学习：
- [注解处理器](./泛型与注解.md)
- [Spring AOP原理](../04-Spring生态/Spring核心.md)

