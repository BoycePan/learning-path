# 泛型与注解

## 📌 学习目标

- 理解泛型的作用和原理
- 掌握泛型类、方法、接口
- 理解类型擦除机制
- 掌握自定义注解
- 了解元注解和注解处理

## ⭐ 核心概念

- **泛型类** ⭐⭐⭐⭐⭐
- **泛型方法** ⭐⭐⭐⭐⭐
- **通配符** ⭐⭐⭐⭐⭐
- **自定义注解** ⭐⭐⭐⭐⭐
- **注解处理器** ⭐⭐⭐⭐

## 1. 泛型基础 ⭐⭐⭐⭐⭐

### 为什么需要泛型？

```java
// 没有泛型的时代（Java 5之前）
List list = new ArrayList();
list.add("Hello");
list.add(123);  // 可以添加任何类型
String str = (String) list.get(0);  // 需要强制转换
String str2 = (String) list.get(1); // 运行时错误！ClassCastException

// 使用泛型（Java 5+）⭐⭐⭐⭐⭐
List<String> list = new ArrayList<>();
list.add("Hello");
// list.add(123);  // 编译错误！类型安全
String str = list.get(0);  // 不需要强制转换
```

**泛型的优点**：
1. **类型安全** - 编译时检查类型
2. **消除强制转换** - 代码更简洁
3. **代码复用** - 一套代码适用多种类型

### 泛型类 ⭐⭐⭐⭐⭐

```java
// 定义泛型类
public class Box<T> {
    private T value;
    
    public Box(T value) {
        this.value = value;
    }
    
    public T getValue() {
        return value;
    }
    
    public void setValue(T value) {
        this.value = value;
    }
}

// 使用泛型类
Box<String> stringBox = new Box<>("Hello");
String str = stringBox.getValue();  // 不需要转换

Box<Integer> intBox = new Box<>(123);
Integer num = intBox.getValue();

// 多个类型参数
public class Pair<K, V> {
    private K key;
    private V value;
    
    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }
    
    public K getKey() { return key; }
    public V getValue() { return value; }
}

// 使用
Pair<String, Integer> pair = new Pair<>("age", 25);
```

### 泛型接口 ⭐⭐⭐⭐⭐

```java
// 定义泛型接口
public interface Comparable<T> {
    int compareTo(T other);
}

// 实现泛型接口
public class Student implements Comparable<Student> {
    private String name;
    private int score;
    
    @Override
    public int compareTo(Student other) {
        return Integer.compare(this.score, other.score);
    }
}

// 泛型接口示例：Repository模式
public interface Repository<T, ID> {
    T findById(ID id);
    List<T> findAll();
    T save(T entity);
    void deleteById(ID id);
}

// 实现
public class UserRepository implements Repository<User, Long> {
    @Override
    public User findById(Long id) {
        // 实现查询逻辑
        return null;
    }
    
    @Override
    public List<User> findAll() {
        return new ArrayList<>();
    }
    
    @Override
    public User save(User entity) {
        // 实现保存逻辑
        return entity;
    }
    
    @Override
    public void deleteById(Long id) {
        // 实现删除逻辑
    }
}
```

### 泛型方法 ⭐⭐⭐⭐⭐

```java
public class GenericMethod {
    
    // 泛型方法 ⭐⭐⭐⭐⭐
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.print(element + " ");
        }
        System.out.println();
    }
    
    // 多个类型参数
    public static <K, V> void printPair(K key, V value) {
        System.out.println(key + " = " + value);
    }
    
    // 有返回值的泛型方法
    public static <T> T getFirst(List<T> list) {
        if (list == null || list.isEmpty()) {
            return null;
        }
        return list.get(0);
    }
    
    // 使用示例
    public static void main(String[] args) {
        Integer[] intArray = {1, 2, 3, 4, 5};
        String[] strArray = {"A", "B", "C"};
        
        printArray(intArray);  // 1 2 3 4 5
        printArray(strArray);  // A B C
        
        printPair("name", "John");
        printPair("age", 25);
        
        List<String> names = Arrays.asList("Alice", "Bob");
        String first = getFirst(names);  // Alice
    }
}
```

## 2. 泛型通配符 ⭐⭐⭐⭐⭐

### 无界通配符 `<?>`

```java
// 接受任何类型的List
public static void printList(List<?> list) {
    for (Object obj : list) {
        System.out.print(obj + " ");
    }
    System.out.println();
}

// 使用
List<Integer> intList = Arrays.asList(1, 2, 3);
List<String> strList = Arrays.asList("A", "B", "C");
printList(intList);  // 1 2 3
printList(strList);  // A B C
```

### 上界通配符 `<? extends T>` ⭐⭐⭐⭐⭐

```java
// 只能读取，不能写入（除了null）
public static double sumOfList(List<? extends Number> list) {
    double sum = 0.0;
    for (Number num : list) {
        sum += num.doubleValue();
    }
    return sum;
}

// 使用
List<Integer> intList = Arrays.asList(1, 2, 3);
List<Double> doubleList = Arrays.asList(1.1, 2.2, 3.3);
System.out.println(sumOfList(intList));     // 6.0
System.out.println(sumOfList(doubleList));  // 6.6

// 实际应用：复制列表
public static <T> void copy(List<? extends T> src, List<? super T> dest) {
    for (T item : src) {
        dest.add(item);
    }
}
```

### 下界通配符 `<? super T>` ⭐⭐⭐⭐⭐

```java
// 只能写入，读取只能是Object
public static void addNumbers(List<? super Integer> list) {
    list.add(1);
    list.add(2);
    list.add(3);
    // Integer num = list.get(0);  // 编译错误
    Object obj = list.get(0);  // 只能读取为Object
}

// 使用
List<Number> numberList = new ArrayList<>();
List<Object> objectList = new ArrayList<>();
addNumbers(numberList);
addNumbers(objectList);
```

### PECS原则 ⭐⭐⭐⭐⭐

**Producer Extends, Consumer Super**

```java
// Producer（生产者）- 使用extends
public static <T> void copyFrom(List<? extends T> source, List<T> dest) {
    for (T item : source) {  // 从source读取
        dest.add(item);
    }
}

// Consumer（消费者）- 使用super
public static <T> void copyTo(List<T> source, List<? super T> dest) {
    for (T item : source) {
        dest.add(item);  // 向dest写入
    }
}
```

## 3. 类型擦除 ⭐⭐⭐⭐⭐

### 什么是类型擦除？

```java
// 编译前
List<String> stringList = new ArrayList<>();
List<Integer> intList = new ArrayList<>();

// 编译后（类型擦除）
List stringList = new ArrayList();
List intList = new ArrayList();

// 因此：
System.out.println(stringList.getClass() == intList.getClass());  // true

// 不能这样做：
// if (list instanceof List<String>) {}  // 编译错误
// new T()  // 编译错误
// T[] array = new T[10];  // 编译错误
```

### 类型擦除的影响

```java
public class GenericClass<T> {
    // 错误：不能创建泛型数组
    // private T[] array = new T[10];
    
    // 正确：使用Object数组
    private Object[] array = new Object[10];
    
    @SuppressWarnings("unchecked")
    public T get(int index) {
        return (T) array[index];
    }
    
    // 错误：不能创建泛型实例
    // public T create() {
    //     return new T();
    // }
    
    // 正确：使用反射创建实例
    public T create(Class<T> clazz) throws Exception {
        return clazz.getDeclaredConstructor().newInstance();
    }
}
```

## 4. 注解基础 ⭐⭐⭐⭐⭐

### 什么是注解？

注解（Annotation）是Java 5引入的一种**元数据**，用于：
1. **编译检查** - @Override, @Deprecated
2. **代码生成** - Lombok
3. **运行时处理** - Spring, MyBatis

### 内置注解 ⭐⭐⭐⭐⭐

```java
// @Override - 检查是否正确重写 ⭐⭐⭐⭐⭐
public class Student {
    @Override
    public String toString() {
        return "Student";
    }
    
    // @Override
    // public String tostring() {  // 编译错误：方法名拼写错误
    //     return "Student";
    // }
}

// @Deprecated - 标记过时 ⭐⭐⭐⭐⭐
public class OldAPI {
    @Deprecated
    public void oldMethod() {
        System.out.println("This method is deprecated");
    }
    
    public void newMethod() {
        System.out.println("Use this method instead");
    }
}

// @SuppressWarnings - 抑制警告 ⭐⭐⭐⭐
public class WarningExample {
    @SuppressWarnings("unchecked")
    public List<String> getList() {
        List list = new ArrayList();  // 原始类型警告被抑制
        return list;
    }
    
    @SuppressWarnings({"unchecked", "deprecation"})
    public void multipleWarnings() {
        // 抑制多个警告
    }
}

// @FunctionalInterface - 函数式接口 ⭐⭐⭐⭐⭐
@FunctionalInterface
public interface Calculator {
    int calculate(int a, int b);
    
    // 只能有一个抽象方法
    // int another(int x);  // 编译错误
    
    // 可以有默认方法和静态方法
    default void print() {
        System.out.println("Calculator");
    }
}
```

## 5. 自定义注解 ⭐⭐⭐⭐⭐

### 定义注解

```java
// 简单注解
public @interface MyAnnotation {
}

// 带参数的注解 ⭐⭐⭐⭐⭐
public @interface Author {
    String name();
    String date();
    int version() default 1;  // 默认值
}

// 使用
@Author(name = "John", date = "2024-01-01")
public class MyClass {
}

@Author(name = "Alice", date = "2024-01-02", version = 2)
public class AnotherClass {
}
```

### 元注解 ⭐⭐⭐⭐⭐

```java
import java.lang.annotation.*;

// @Target - 注解的使用位置 ⭐⭐⭐⭐⭐
@Target({
    ElementType.TYPE,        // 类、接口、枚举
    ElementType.FIELD,       // 字段
    ElementType.METHOD,      // 方法
    ElementType.PARAMETER,   // 参数
    ElementType.CONSTRUCTOR, // 构造器
    ElementType.LOCAL_VARIABLE  // 局部变量
})
// @Retention - 注解的保留策略 ⭐⭐⭐⭐⭐
@Retention(RetentionPolicy.RUNTIME)  // 运行时可见（最常用）
// RetentionPolicy.SOURCE   // 源码级别，编译后丢弃
// RetentionPolicy.CLASS    // 字节码级别，运行时丢弃
// @Documented - 包含在JavaDoc中
@Documented
// @Inherited - 可被继承
@Inherited
public @interface MyAnnotation {
    String value();
}
```

### 实用注解示例 ⭐⭐⭐⭐⭐

```java
// 1. 字段验证注解
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface NotNull {
    String message() default "Field cannot be null";
}

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Length {
    int min() default 0;
    int max() default Integer.MAX_VALUE;
    String message() default "Length is invalid";
}

// 使用
public class User {
    @NotNull(message = "用户名不能为空")
    @Length(min = 3, max = 20, message = "用户名长度必须在3-20之间")
    private String username;
    
    @NotNull
    private String email;
    
    // getters and setters
}

// 2. 方法日志注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Log {
    String value() default "";
    boolean printArgs() default true;
    boolean printResult() default true;
}

// 使用
public class UserService {
    @Log("查询用户")
    public User findById(Long id) {
        // 查询逻辑
        return new User();
    }
    
    @Log(value = "保存用户", printResult = false)
    public void save(User user) {
        // 保存逻辑
    }
}

// 3. 权限注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequirePermission {
    String[] value();  // 需要的权限
}

// 使用
public class AdminController {
    @RequirePermission({"admin", "user:delete"})
    public void deleteUser(Long id) {
        // 删除用户
    }
}
```

## 6. 注解处理 ⭐⭐⭐⭐⭐

### 运行时注解处理（反射）

```java
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class AnnotationProcessor {
    
    // 处理字段注解
    public static void validate(Object obj) throws Exception {
        Class<?> clazz = obj.getClass();
        
        for (Field field : clazz.getDeclaredFields()) {
            field.setAccessible(true);
            Object value = field.get(obj);
            
            // 检查@NotNull
            if (field.isAnnotationPresent(NotNull.class)) {
                if (value == null) {
                    NotNull annotation = field.getAnnotation(NotNull.class);
                    throw new IllegalArgumentException(annotation.message());
                }
            }
            
            // 检查@Length
            if (field.isAnnotationPresent(Length.class)) {
                if (value instanceof String) {
                    String str = (String) value;
                    Length annotation = field.getAnnotation(Length.class);
                    if (str.length() < annotation.min() || 
                        str.length() > annotation.max()) {
                        throw new IllegalArgumentException(annotation.message());
                    }
                }
            }
        }
    }
    
    // 测试
    public static void main(String[] args) {
        User user = new User();
        user.setUsername("ab");  // 长度不够
        
        try {
            validate(user);
        } catch (Exception e) {
            System.out.println(e.getMessage());  // 用户名长度必须在3-20之间
        }
    }
}
```

## 💡 最佳实践 ⭐⭐⭐⭐⭐

### 1. 泛型命名规范

```java
// 常用泛型名称
T - Type（类型）
E - Element（元素）
K - Key（键）
V - Value（值）
N - Number（数字）
R - Result（结果）

// 示例
public class Cache<K, V> {
    private Map<K, V> map = new HashMap<>();
}

public interface Function<T, R> {
    R apply(T t);
}
```

### 2. 注解设计原则

```java
// 1. 使用有意义的名称
@UserPermission  // 好
@UP             // 不好

// 2. 提供默认值
public @interface Cache {
    int timeout() default 3600;  // 默认1小时
    String key() default "";
}

// 3. 使用枚举限制取值
public @interface RequestMapping {
    RequestMethod method() default RequestMethod.GET;
}

public enum RequestMethod {
    GET, POST, PUT, DELETE
}
```

## 🎯 实战练习

1. 实现一个泛型的LRU缓存
2. 创建自定义验证注解
3. 实现注解处理器进行参数校验
4. 使用泛型实现通用的DAO层

## 📚 下一步

学习完泛型与注解后，继续学习：
- [反射与动态代理](./反射与动态代理.md)
- [集合框架](./集合框架.md)

