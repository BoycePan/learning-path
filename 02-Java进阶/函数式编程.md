# Java函数式编程

## 📌 学习目标

- 理解函数式编程思想
- 掌握Lambda表达式
- 熟练使用Stream API
- 了解函数式接口
- 掌握Optional类

## ⭐ 函数式编程核心概念

- **Lambda表达式** ⭐⭐⭐⭐⭐
- **函数式接口** ⭐⭐⭐⭐⭐
- **Stream API** ⭐⭐⭐⭐⭐
- **方法引用** ⭐⭐⭐⭐
- **Optional** ⭐⭐⭐⭐⭐

## 1. Lambda表达式 ⭐⭐⭐⭐⭐

### 基本语法

```java
/**
 * Lambda表达式语法 ⭐⭐⭐⭐⭐
 * (参数列表) -> { 方法体 }
 */
public class LambdaBasic {
    public static void main(String[] args) {
        // 1. 无参数Lambda
        Runnable r1 = () -> System.out.println("Hello Lambda!");
        r1.run();
        
        // 2. 单参数Lambda（可省略括号）
        // 传统写法
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("传统写法");
            }
        });
        
        // Lambda写法 ⭐⭐⭐⭐⭐
        Thread t2 = new Thread(() -> System.out.println("Lambda写法"));
        
        // 3. 多参数Lambda
        // 传统Comparator
        Comparator<Integer> comp1 = new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1.compareTo(o2);
            }
        };
        
        // Lambda Comparator ⭐⭐⭐⭐⭐
        Comparator<Integer> comp2 = (o1, o2) -> o1.compareTo(o2);
        
        // 4. 有返回值的Lambda
        Calculator add = (a, b) -> a + b;
        Calculator subtract = (a, b) -> a - b;
        Calculator multiply = (a, b) -> a * b;
        Calculator divide = (a, b) -> a / b;
        
        System.out.println("10 + 5 = " + add.calculate(10, 5));
        System.out.println("10 - 5 = " + subtract.calculate(10, 5));
        System.out.println("10 * 5 = " + multiply.calculate(10, 5));
        System.out.println("10 / 5 = " + divide.calculate(10, 5));
    }
}

@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
}
```

### Lambda实战应用

```java
import java.util.*;

public class LambdaDemo {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("张三", "李四", "王五", "赵六");
        
        // 1. 遍历集合 ⭐⭐⭐⭐⭐
        // 传统方式
        for (String name : names) {
            System.out.println(name);
        }
        
        // Lambda方式
        names.forEach(name -> System.out.println(name));
        
        // 方法引用（更简洁）
        names.forEach(System.out::println);
        
        // 2. 排序 ⭐⭐⭐⭐⭐
        List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 9);
        
        // 升序
        numbers.sort((a, b) -> a - b);
        System.out.println("升序：" + numbers);
        
        // 降序
        numbers.sort((a, b) -> b - a);
        System.out.println("降序：" + numbers);
        
        // 3. 线程 ⭐⭐⭐⭐⭐
        new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                System.out.println("线程执行：" + i);
            }
        }).start();
        
        // 4. 自定义操作 ⭐⭐⭐⭐
        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5);
        processNumbers(nums, n -> n * 2);        // 乘以2
        processNumbers(nums, n -> n * n);        // 平方
        processNumbers(nums, n -> n + 100);      // 加100
    }
    
    public static void processNumbers(List<Integer> numbers, 
                                      NumberProcessor processor) {
        for (Integer num : numbers) {
            System.out.print(processor.process(num) + " ");
        }
        System.out.println();
    }
}

@FunctionalInterface
interface NumberProcessor {
    int process(int num);
}
```

## 2. 函数式接口 ⭐⭐⭐⭐⭐

### 内置函数式接口

```java
import java.util.function.*;

/**
 * Java内置函数式接口 ⭐⭐⭐⭐⭐
 */
public class FunctionalInterfaceDemo {
    public static void main(String[] args) {
        // 1. Consumer<T> - 消费型接口（有参无返回） ⭐⭐⭐⭐⭐
        Consumer<String> printer = str -> System.out.println(str);
        printer.accept("Hello Consumer!");
        
        // 2. Supplier<T> - 供给型接口（无参有返回） ⭐⭐⭐⭐⭐
        Supplier<Double> randomSupplier = () -> Math.random();
        System.out.println("随机数：" + randomSupplier.get());
        
        // 3. Function<T, R> - 函数型接口（有参有返回） ⭐⭐⭐⭐⭐
        Function<String, Integer> lengthFunc = str -> str.length();
        System.out.println("字符串长度：" + lengthFunc.apply("Hello"));
        
        // 4. Predicate<T> - 断言型接口（有参返回boolean） ⭐⭐⭐⭐⭐
        Predicate<Integer> isEven = num -> num % 2 == 0;
        System.out.println("4是偶数：" + isEven.test(4));
        System.out.println("5是偶数：" + isEven.test(5));
        
        // 5. BiFunction<T, U, R> - 双参数函数 ⭐⭐⭐⭐
        BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;
        System.out.println("3 + 5 = " + add.apply(3, 5));
        
        // 6. UnaryOperator<T> - 一元操作符 ⭐⭐⭐⭐
        UnaryOperator<Integer> square = num -> num * num;
        System.out.println("5的平方：" + square.apply(5));
        
        // 7. BinaryOperator<T> - 二元操作符 ⭐⭐⭐⭐
        BinaryOperator<Integer> multiply = (a, b) -> a * b;
        System.out.println("3 * 4 = " + multiply.apply(3, 4));
    }
}
```

### 自定义函数式接口

```java
/**
 * 自定义函数式接口 ⭐⭐⭐⭐
 */
@FunctionalInterface  // 可选，但推荐添加
interface StringProcessor {
    String process(String input);
    
    // 可以有默认方法
    default String processUpperCase(String input) {
        return process(input).toUpperCase();
    }
    
    // 可以有静态方法
    static String reverse(String str) {
        return new StringBuilder(str).reverse().toString();
    }
}

public class CustomFunctionalInterface {
    public static void main(String[] args) {
        // 使用Lambda实现
        StringProcessor toUpper = str -> str.toUpperCase();
        StringProcessor toLower = str -> str.toLowerCase();
        StringProcessor removeSpaces = str -> str.replace(" ", "");
        
        String text = "Hello World";
        System.out.println("大写：" + toUpper.process(text));
        System.out.println("小写：" + toLower.process(text));
        System.out.println("去空格：" + removeSpaces.process(text));
        
        // 使用默认方法
        System.out.println("默认方法：" + toLower.processUpperCase(text));
        
        // 使用静态方法
        System.out.println("反转：" + StringProcessor.reverse(text));
    }
}
```

## 3. Stream API ⭐⭐⭐⭐⭐

### Stream基础操作

```java
import java.util.*;
import java.util.stream.*;

/**
 * Stream API基础 ⭐⭐⭐⭐⭐
 */
public class StreamBasic {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // 1. filter - 过滤 ⭐⭐⭐⭐⭐
        List<Integer> evens = numbers.stream()
            .filter(n -> n % 2 == 0)
            .collect(Collectors.toList());
        System.out.println("偶数：" + evens);
        
        // 2. map - 映射转换 ⭐⭐⭐⭐⭐
        List<Integer> squares = numbers.stream()
            .map(n -> n * n)
            .collect(Collectors.toList());
        System.out.println("平方：" + squares);
        
        // 3. sorted - 排序 ⭐⭐⭐⭐⭐
        List<Integer> sorted = numbers.stream()
            .sorted((a, b) -> b - a)  // 降序
            .collect(Collectors.toList());
        System.out.println("降序：" + sorted);
        
        // 4. limit - 限制数量 ⭐⭐⭐⭐
        List<Integer> first5 = numbers.stream()
            .limit(5)
            .collect(Collectors.toList());
        System.out.println("前5个：" + first5);
        
        // 5. skip - 跳过 ⭐⭐⭐⭐
        List<Integer> skip3 = numbers.stream()
            .skip(3)
            .collect(Collectors.toList());
        System.out.println("跳过前3个：" + skip3);
        
        // 6. distinct - 去重 ⭐⭐⭐⭐⭐
        List<Integer> duplicates = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 5);
        List<Integer> unique = duplicates.stream()
            .distinct()
            .collect(Collectors.toList());
        System.out.println("去重：" + unique);
        
        // 7. forEach - 遍历 ⭐⭐⭐⭐⭐
        System.out.print("遍历：");
        numbers.stream()
            .filter(n -> n > 5)
            .forEach(n -> System.out.print(n + " "));
        System.out.println();
    }
}
```

### Stream高级操作

```java
import java.util.*;
import java.util.stream.*;

public class StreamAdvanced {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // 1. reduce - 归约 ⭐⭐⭐⭐⭐
        int sum = numbers.stream()
            .reduce(0, (a, b) -> a + b);
        System.out.println("总和：" + sum);
        
        int product = numbers.stream()
            .reduce(1, (a, b) -> a * b);
        System.out.println("乘积：" + product);
        
        // 2. count - 计数 ⭐⭐⭐⭐⭐
        long count = numbers.stream()
            .filter(n -> n > 5)
            .count();
        System.out.println("大于5的数量：" + count);
        
        // 3. anyMatch, allMatch, noneMatch ⭐⭐⭐⭐⭐
        boolean hasEven = numbers.stream().anyMatch(n -> n % 2 == 0);
        boolean allPositive = numbers.stream().allMatch(n -> n > 0);
        boolean noneNegative = numbers.stream().noneMatch(n -> n < 0);
        
        System.out.println("是否有偶数：" + hasEven);
        System.out.println("是否全部正数：" + allPositive);
        System.out.println("是否没有负数：" + noneNegative);
        
        // 4. findFirst, findAny ⭐⭐⭐⭐
        Optional<Integer> first = numbers.stream()
            .filter(n -> n > 5)
            .findFirst();
        first.ifPresent(n -> System.out.println("第一个大于5的数：" + n));
        
        // 5. max, min ⭐⭐⭐⭐⭐
        Optional<Integer> max = numbers.stream().max(Integer::compareTo);
        Optional<Integer> min = numbers.stream().min(Integer::compareTo);
        
        System.out.println("最大值：" + max.orElse(0));
        System.out.println("最小值：" + min.orElse(0));
        
        // 6. flatMap - 扁平化 ⭐⭐⭐⭐⭐
        List<List<Integer>> listOfLists = Arrays.asList(
            Arrays.asList(1, 2, 3),
            Arrays.asList(4, 5, 6),
            Arrays.asList(7, 8, 9)
        );
        
        List<Integer> flattened = listOfLists.stream()
            .flatMap(List::stream)
            .collect(Collectors.toList());
        System.out.println("扁平化：" + flattened);
        
        // 7. collect - 收集 ⭐⭐⭐⭐⭐
        // 转为Set
        Set<Integer> set = numbers.stream().collect(Collectors.toSet());
        
        // 转为Map
        Map<Integer, String> map = numbers.stream()
            .collect(Collectors.toMap(
                n -> n,
                n -> "Number_" + n
            ));
        
        // 分组
        Map<Boolean, List<Integer>> partitioned = numbers.stream()
            .collect(Collectors.partitioningBy(n -> n % 2 == 0));
        System.out.println("偶数：" + partitioned.get(true));
        System.out.println("奇数：" + partitioned.get(false));
    }
}
```

### Stream实战案例 ⭐⭐⭐⭐⭐

```java
import java.util.*;
import java.util.stream.*;

class Student {
    private String name;
    private int age;
    private String gender;
    private double score;
    
    public Student(String name, int age, String gender, double score) {
        this.name = name;
        this.age = age;
        this.gender = gender;
        this.score = score;
    }
    
    // Getters
    public String getName() { return name; }
    public int getAge() { return age; }
    public String getGender() { return gender; }
    public double getScore() { return score; }
    
    @Override
    public String toString() {
        return name + "(" + age + "岁," + gender + ",分数:" + score + ")";
    }
}

public class StreamPractice {
    public static void main(String[] args) {
        List<Student> students = Arrays.asList(
            new Student("张三", 20, "男", 85.5),
            new Student("李四", 22, "女", 92.0),
            new Student("王五", 21, "男", 78.5),
            new Student("赵六", 20, "女", 88.0),
            new Student("孙七", 23, "男", 95.5)
        );
        
        // 1. 找出所有成绩大于80分的学生 ⭐⭐⭐⭐⭐
        System.out.println("成绩大于80分的学生：");
        students.stream()
            .filter(s -> s.getScore() > 80)
            .forEach(System.out::println);
        
        // 2. 计算平均分 ⭐⭐⭐⭐⭐
        double avgScore = students.stream()
            .mapToDouble(Student::getScore)
            .average()
            .orElse(0.0);
        System.out.println("\n平均分：" + avgScore);
        
        // 3. 按性别分组 ⭐⭐⭐⭐⭐
        Map<String, List<Student>> byGender = students.stream()
            .collect(Collectors.groupingBy(Student::getGender));
        System.out.println("\n按性别分组：");
        byGender.forEach((gender, list) -> {
            System.out.println(gender + "：" + list);
        });
        
        // 4. 找出成绩最高的学生 ⭐⭐⭐⭐⭐
        Optional<Student> topStudent = students.stream()
            .max(Comparator.comparing(Student::getScore));
        topStudent.ifPresent(s -> 
            System.out.println("\n成绩最高：" + s));
        
        // 5. 获取所有学生姓名列表 ⭐⭐⭐⭐⭐
        List<String> names = students.stream()
            .map(Student::getName)
            .collect(Collectors.toList());
        System.out.println("\n学生姓名：" + names);
        
        // 6. 按成绩排序 ⭐⭐⭐⭐⭐
        System.out.println("\n按成绩降序：");
        students.stream()
            .sorted(Comparator.comparing(Student::getScore).reversed())
            .forEach(System.out::println);
        
        // 7. 统计各年龄段人数 ⭐⭐⭐⭐
        Map<Integer, Long> ageCount = students.stream()
            .collect(Collectors.groupingBy(
                Student::getAge,
                Collectors.counting()
            ));
        System.out.println("\n各年龄人数：" + ageCount);
        
        // 8. 成绩汇总统计 ⭐⭐⭐⭐⭐
        DoubleSummaryStatistics stats = students.stream()
            .mapToDouble(Student::getScore)
            .summaryStatistics();
        System.out.println("\n成绩统计：");
        System.out.println("人数：" + stats.getCount());
        System.out.println("总分：" + stats.getSum());
        System.out.println("平均分：" + stats.getAverage());
        System.out.println("最高分：" + stats.getMax());
        System.out.println("最低分：" + stats.getMin());
    }
}
```

## 4. 方法引用 ⭐⭐⭐⭐

```java
import java.util.*;
import java.util.function.*;

/**
 * 方法引用 ⭐⭐⭐⭐
 * 语法：类名::方法名
 */
public class MethodReferenceDemo {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("张三", "李四", "王五");
        
        // 1. 静态方法引用 ⭐⭐⭐⭐⭐
        // Lambda: str -> Integer.parseInt(str)
        Function<String, Integer> parser = Integer::parseInt;
        System.out.println("解析：" + parser.apply("123"));
        
        // 2. 实例方法引用 ⭐⭐⭐⭐⭐
        // Lambda: str -> str.length()
        Function<String, Integer> lengthFunc = String::length;
        System.out.println("长度：" + lengthFunc.apply("Hello"));
        
        // 3. 对象方法引用 ⭐⭐⭐⭐
        // Lambda: str -> System.out.println(str)
        Consumer<String> printer = System.out::println;
        names.forEach(printer);
        
        // 4. 构造方法引用 ⭐⭐⭐⭐⭐
        // Lambda: () -> new ArrayList<>()
        Supplier<List<String>> listSupplier = ArrayList::new;
        List<String> list = listSupplier.get();
        
        // 实际应用
        System.out.println("\n方法引用应用：");
        names.stream()
            .map(String::toUpperCase)  // 方法引用
            .forEach(System.out::println);  // 方法引用
    }
}
```

## 5. Optional类 ⭐⭐⭐⭐⭐

```java
import java.util.Optional;

/**
 * Optional - 避免空指针异常 ⭐⭐⭐⭐⭐
 */
public class OptionalDemo {
    public static void main(String[] args) {
        // 1. 创建Optional ⭐⭐⭐⭐⭐
        Optional<String> optional1 = Optional.of("Hello");  // 非空
        Optional<String> optional2 = Optional.ofNullable(null);  // 可能为空
        Optional<String> optional3 = Optional.empty();  // 空
        
        // 2. 判断是否有值 ⭐⭐⭐⭐⭐
        System.out.println("是否有值：" + optional1.isPresent());
        System.out.println("是否为空：" + optional2.isEmpty());  // Java 11+
        
        // 3. 获取值 ⭐⭐⭐⭐⭐
        // get() - 不推荐，可能抛出异常
        // String value1 = optional1.get();
        
        // orElse() - 推荐，提供默认值 ⭐⭐⭐⭐⭐
        String value2 = optional2.orElse("默认值");
        System.out.println("orElse：" + value2);
        
        // orElseGet() - 懒加载默认值
        String value3 = optional2.orElseGet(() -> "懒加载默认值");
        System.out.println("orElseGet：" + value3);
        
        // orElseThrow() - 抛出自定义异常
        try {
            String value4 = optional2.orElseThrow(() -> 
                new IllegalArgumentException("值为空"));
        } catch (IllegalArgumentException e) {
            System.out.println("异常：" + e.getMessage());
        }
        
        // 4. ifPresent - 如果有值则执行 ⭐⭐⭐⭐⭐
        optional1.ifPresent(val -> System.out.println("值：" + val));
        
        // 5. map - 转换 ⭐⭐⭐⭐⭐
        Optional<Integer> length = optional1.map(String::length);
        System.out.println("字符串长度：" + length.orElse(0));
        
        // 6. filter - 过滤 ⭐⭐⭐⭐
        optional1.filter(str -> str.length() > 3)
                 .ifPresent(str -> System.out.println("长度>3：" + str));
        
        // 7. flatMap - 扁平化 ⭐⭐⭐⭐
        Optional<String> result = optional1.flatMap(str -> 
            Optional.of(str.toUpperCase())
        );
        System.out.println("flatMap：" + result.orElse(""));
        
        // 实际应用示例 ⭐⭐⭐⭐⭐
        User user = findUserById(1);
        
        // 传统写法
        if (user != null && user.getEmail() != null) {
            System.out.println("邮箱：" + user.getEmail());
        }
        
        // Optional写法（推荐）
        findUserByIdOptional(1)
            .map(User::getEmail)
            .ifPresent(email -> System.out.println("邮箱：" + email));
    }
    
    // 传统方法
    public static User findUserById(int id) {
        // 可能返回null
        return new User(1, "张三", "zhang@example.com");
    }
    
    // Optional方法（推荐）
    public static Optional<User> findUserByIdOptional(int id) {
        User user = new User(id, "张三", "zhang@example.com");
        return Optional.ofNullable(user);
    }
}

class User {
    private int id;
    private String name;
    private String email;
    
    public User(int id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }
    
    public String getEmail() { return email; }
}
```

## 💡 重点总结

### Lambda vs 传统方式 ⭐⭐⭐⭐⭐

| 场景 | 传统方式 | Lambda方式 | 推荐 |
|------|---------|-----------|------|
| 遍历 | for循环 | forEach | ⭐⭐⭐⭐⭐ |
| 排序 | Comparator匿名类 | (a,b)->a-b | ⭐⭐⭐⭐⭐ |
| 过滤 | for+if | filter | ⭐⭐⭐⭐⭐ |
| 转换 | for+新建对象 | map | ⭐⭐⭐⭐⭐ |
| 线程 | Runnable匿名类 | ()->code | ⭐⭐⭐⭐⭐ |

### Stream操作分类 ⭐⭐⭐⭐⭐

**中间操作**（返回Stream，可链式调用）：
- filter, map, flatMap, sorted, distinct, limit, skip

**终端操作**（返回结果，结束流）：
- forEach, collect, reduce, count, anyMatch, findFirst, max, min

### 最佳实践 ⭐⭐⭐⭐⭐

```java
// ✅ 推荐：使用Optional避免null
public Optional<User> findUser(int id) {
    return Optional.ofNullable(userMap.get(id));
}

// ✅ 推荐：使用Stream简化集合操作
List<String> names = users.stream()
    .map(User::getName)
    .collect(Collectors.toList());

// ✅ 推荐：使用方法引用
list.forEach(System.out::println);

// ❌ 不推荐：过度使用Stream
// 简单循环不需要Stream
for (String item : list) {
    process(item);
}
```

## 🎯 练习建议

1. 重写之前的代码，使用Lambda表达式
2. 用Stream实现数据统计分析
3. 实现一个简单的函数式工具类
4. 练习Optional的各种用法

## 📚 下一步

完成Java进阶学习后，继续学习 [数据库技术](../03-数据库/)

