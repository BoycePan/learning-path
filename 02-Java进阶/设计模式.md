# Java设计模式

## 📌 学习目标

- 理解设计模式的概念
- 掌握常用设计模式
- 理解设计原则
- 能在实际项目中应用
- 识别框架中的设计模式

## ⭐ 核心内容

- **单例模式** ⭐⭐⭐⭐⭐
- **工厂模式** ⭐⭐⭐⭐⭐
- **代理模式** ⭐⭐⭐⭐⭐
- **观察者模式** ⭐⭐⭐⭐⭐
- **策略模式** ⭐⭐⭐⭐⭐

## 1. 设计模式概述 ⭐⭐⭐⭐⭐

### 什么是设计模式？

设计模式是**软件设计中常见问题的典型解决方案**，是前人经验的总结。

### 六大设计原则 ⭐⭐⭐⭐⭐

```java
// 1. 单一职责原则（SRP）⭐⭐⭐⭐⭐
// 一个类只负责一个功能
class UserService {
    void saveUser(User user) { }  // 只负责用户业务
}
class UserValidator {
    boolean validate(User user) { }  // 只负责验证
}

// 2. 开闭原则（OCP）⭐⭐⭐⭐⭐
// 对扩展开放，对修改关闭
interface PaymentStrategy {
    void pay(double amount);
}
class AlipayPayment implements PaymentStrategy { }
class WechatPayment implements PaymentStrategy { }

// 3. 里氏替换原则（LSP）⭐⭐⭐⭐
// 子类可以替换父类
class Bird { void fly() { } }
class Sparrow extends Bird { }  // 可以替换Bird

// 4. 接口隔离原则（ISP）⭐⭐⭐⭐
// 接口应该小而专一
interface Readable { void read(); }
interface Writable { void write(); }

// 5. 依赖倒置原则（DIP）⭐⭐⭐⭐⭐
// 依赖抽象而不是具体实现
class UserService {
    private UserRepository repository;  // 依赖接口
    UserService(UserRepository repository) {
        this.repository = repository;
    }
}

// 6. 迪米特法则（LoD）⭐⭐⭐⭐
// 最少知识原则，降低耦合
```

## 2. 创建型模式

### 单例模式 ⭐⭐⭐⭐⭐

```java
// 1. 饿汉式（线程安全，推荐）⭐⭐⭐⭐⭐
public class Singleton1 {
    private static final Singleton1 INSTANCE = new Singleton1();
    
    private Singleton1() {}
    
    public static Singleton1 getInstance() {
        return INSTANCE;
    }
}

// 2. 懒汉式（双重检查锁，推荐）⭐⭐⭐⭐⭐
public class Singleton2 {
    private static volatile Singleton2 instance;
    
    private Singleton2() {}
    
    public static Singleton2 getInstance() {
        if (instance == null) {
            synchronized (Singleton2.class) {
                if (instance == null) {
                    instance = new Singleton2();
                }
            }
        }
        return instance;
    }
}

// 3. 静态内部类（推荐）⭐⭐⭐⭐⭐
public class Singleton3 {
    private Singleton3() {}
    
    private static class Holder {
        private static final Singleton3 INSTANCE = new Singleton3();
    }
    
    public static Singleton3 getInstance() {
        return Holder.INSTANCE;
    }
}

// 4. 枚举（最安全，推荐）⭐⭐⭐⭐⭐
public enum Singleton4 {
    INSTANCE;
    
    public void doSomething() {
        System.out.println("Singleton method");
    }
}

// 使用场景：数据库连接池、配置管理器、日志对象
```

### 工厂模式 ⭐⭐⭐⭐⭐

```java
// 简单工厂 ⭐⭐⭐⭐⭐
interface Product {
    void use();
}

class ProductA implements Product {
    public void use() { System.out.println("使用产品A"); }
}

class ProductB implements Product {
    public void use() { System.out.println("使用产品B"); }
}

class SimpleFactory {
    public static Product createProduct(String type) {
        switch (type) {
            case "A": return new ProductA();
            case "B": return new ProductB();
            default: throw new IllegalArgumentException("未知类型");
        }
    }
}

// 工厂方法 ⭐⭐⭐⭐⭐
interface Factory {
    Product createProduct();
}

class FactoryA implements Factory {
    public Product createProduct() {
        return new ProductA();
    }
}

class FactoryB implements Factory {
    public Product createProduct() {
        return new ProductB();
    }
}

// 抽象工厂 ⭐⭐⭐⭐
interface AbstractFactory {
    Product createProductA();
    Product createProductB();
}

class ConcreteFactory implements AbstractFactory {
    public Product createProductA() { return new ProductA(); }
    public Product createProductB() { return new ProductB(); }
}

// 使用场景：Spring BeanFactory、JDBC DriverManager
```

### 建造者模式 ⭐⭐⭐⭐⭐

```java
// 复杂对象的构建
public class User {
    private final String name;        // 必填
    private final String email;       // 必填
    private final int age;            // 可选
    private final String phone;       // 可选
    private final String address;     // 可选
    
    private User(Builder builder) {
        this.name = builder.name;
        this.email = builder.email;
        this.age = builder.age;
        this.phone = builder.phone;
        this.address = builder.address;
    }
    
    public static class Builder {
        private final String name;
        private final String email;
        private int age;
        private String phone;
        private String address;
        
        public Builder(String name, String email) {
            this.name = name;
            this.email = email;
        }
        
        public Builder age(int age) {
            this.age = age;
            return this;
        }
        
        public Builder phone(String phone) {
            this.phone = phone;
            return this;
        }
        
        public Builder address(String address) {
            this.address = address;
            return this;
        }
        
        public User build() {
            return new User(this);
        }
    }
}

// 使用 ⭐⭐⭐⭐⭐
User user = new User.Builder("Alice", "alice@example.com")
    .age(25)
    .phone("13800138000")
    .address("Beijing")
    .build();

// 使用场景：Lombok @Builder、StringBuilder、Stream.Builder
```

## 3. 结构型模式

### 代理模式 ⭐⭐⭐⭐⭐

```java
// 静态代理
interface UserService {
    void save(User user);
}

class UserServiceImpl implements UserService {
    public void save(User user) {
        System.out.println("保存用户：" + user.getName());
    }
}

class UserServiceProxy implements UserService {
    private UserService target;
    
    public UserServiceProxy(UserService target) {
        this.target = target;
    }
    
    public void save(User user) {
        System.out.println("开启事务");
        target.save(user);
        System.out.println("提交事务");
    }
}

// 动态代理见"反射与动态代理"章节 ⭐⭐⭐⭐⭐
// 使用场景：Spring AOP、MyBatis Mapper、RPC框架
```

### 装饰器模式 ⭐⭐⭐⭐

```java
// 动态添加功能
interface Coffee {
    double cost();
    String description();
}

class SimpleCoffee implements Coffee {
    public double cost() { return 10.0; }
    public String description() { return "普通咖啡"; }
}

abstract class CoffeeDecorator implements Coffee {
    protected Coffee coffee;
    
    public CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
}

class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) { super(coffee); }
    
    public double cost() { return coffee.cost() + 2.0; }
    public String description() { return coffee.description() + " + 牛奶"; }
}

class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) { super(coffee); }
    
    public double cost() { return coffee.cost() + 1.0; }
    public String description() { return coffee.description() + " + 糖"; }
}

// 使用 ⭐⭐⭐⭐⭐
Coffee coffee = new SimpleCoffee();
coffee = new MilkDecorator(coffee);
coffee = new SugarDecorator(coffee);
System.out.println(coffee.description() + " = " + coffee.cost());
// 输出：普通咖啡 + 牛奶 + 糖 = 13.0

// 使用场景：Java IO流、Spring Cache
```

### 适配器模式 ⭐⭐⭐⭐

```java
// 将一个接口转换成另一个接口
interface Target {
    void request();
}

class Adaptee {
    void specificRequest() {
        System.out.println("特殊请求");
    }
}

class Adapter implements Target {
    private Adaptee adaptee;
    
    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }
    
    public void request() {
        adaptee.specificRequest();
    }
}

// 使用场景：Spring MVC HandlerAdapter、JDBC-ODBC桥
```

## 4. 行为型模式

### 策略模式 ⭐⭐⭐⭐⭐

```java
// 定义一系列算法，让它们可以互相替换
interface PaymentStrategy {
    void pay(double amount);
}

class AlipayStrategy implements PaymentStrategy {
    public void pay(double amount) {
        System.out.println("支付宝支付：" + amount);
    }
}

class WechatStrategy implements PaymentStrategy {
    public void pay(double amount) {
        System.out.println("微信支付：" + amount);
    }
}

class CreditCardStrategy implements PaymentStrategy {
    public void pay(double amount) {
        System.out.println("信用卡支付：" + amount);
    }
}

class PaymentContext {
    private PaymentStrategy strategy;
    
    public void setStrategy(PaymentStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void pay(double amount) {
        strategy.pay(amount);
    }
}

// 使用 ⭐⭐⭐⭐⭐
PaymentContext context = new PaymentContext();
context.setStrategy(new AlipayStrategy());
context.pay(100.0);

context.setStrategy(new WechatStrategy());
context.pay(200.0);

// 使用场景：支付方式、排序算法、Spring Resource
```

### 观察者模式 ⭐⭐⭐⭐⭐

```java
// 一对多依赖，当一个对象状态改变时，所有依赖者都会收到通知
interface Observer {
    void update(String message);
}

class ConcreteObserver implements Observer {
    private String name;
    
    public ConcreteObserver(String name) {
        this.name = name;
    }
    
    public void update(String message) {
        System.out.println(name + " 收到消息：" + message);
    }
}

class Subject {
    private List<Observer> observers = new ArrayList<>();
    
    public void attach(Observer observer) {
        observers.add(observer);
    }
    
    public void detach(Observer observer) {
        observers.remove(observer);
    }
    
    public void notifyObservers(String message) {
        for (Observer observer : observers) {
            observer.update(message);
        }
    }
}

// 使用 ⭐⭐⭐⭐⭐
Subject subject = new Subject();
subject.attach(new ConcreteObserver("观察者1"));
subject.attach(new ConcreteObserver("观察者2"));
subject.notifyObservers("Hello!");

// 使用场景：Spring Event、MQ消息、GUI事件
```

### 模板方法模式 ⭐⭐⭐⭐⭐

```java
// 定义算法骨架，子类实现具体步骤
abstract class AbstractTemplate {
    // 模板方法 ⭐⭐⭐⭐⭐
    public final void execute() {
        step1();
        step2();
        step3();
    }
    
    protected abstract void step1();
    protected abstract void step2();
    
    protected void step3() {
        System.out.println("默认实现");
    }
}

class ConcreteTemplate extends AbstractTemplate {
    protected void step1() {
        System.out.println("具体实现1");
    }
    
    protected void step2() {
        System.out.println("具体实现2");
    }
}

// 使用场景：Spring JdbcTemplate、Servlet、JUnit
```

### 责任链模式 ⭐⭐⭐⭐

```java
// 请求沿着链传递，直到有对象处理它
abstract class Handler {
    protected Handler next;
    
    public void setNext(Handler next) {
        this.next = next;
    }
    
    public abstract void handleRequest(Request request);
}

class ConcreteHandler1 extends Handler {
    public void handleRequest(Request request) {
        if (request.getLevel() == 1) {
            System.out.println("Handler1处理");
        } else if (next != null) {
            next.handleRequest(request);
        }
    }
}

class ConcreteHandler2 extends Handler {
    public void handleRequest(Request request) {
        if (request.getLevel() == 2) {
            System.out.println("Handler2处理");
        } else if (next != null) {
            next.handleRequest(request);
        }
    }
}

// 使用 ⭐⭐⭐⭐⭐
Handler h1 = new ConcreteHandler1();
Handler h2 = new ConcreteHandler2();
h1.setNext(h2);
h1.handleRequest(new Request(2));

// 使用场景：Servlet Filter、Spring Interceptor、Netty Pipeline
```

## 5. 框架中的设计模式 ⭐⭐⭐⭐⭐

### Spring框架

```java
// 1. 单例模式 - Spring Bean默认单例 ⭐⭐⭐⭐⭐
@Component
public class UserService { }

// 2. 工厂模式 - BeanFactory ⭐⭐⭐⭐⭐
ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
UserService service = context.getBean(UserService.class);

// 3. 代理模式 - AOP ⭐⭐⭐⭐⭐
@Aspect
public class LogAspect {
    @Around("execution(* com.example..*(..))")
    public Object log(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("方法执行前");
        Object result = pjp.proceed();
        System.out.println("方法执行后");
        return result;
    }
}

// 4. 模板方法 - JdbcTemplate ⭐⭐⭐⭐⭐
jdbcTemplate.query("SELECT * FROM user", (rs, rowNum) -> {
    User user = new User();
    user.setId(rs.getLong("id"));
    user.setName(rs.getString("name"));
    return user;
});

// 5. 观察者模式 - ApplicationEvent ⭐⭐⭐⭐⭐
@Component
public class UserEventListener {
    @EventListener
    public void handleUserCreated(UserCreatedEvent event) {
        System.out.println("用户创建：" + event.getUser());
    }
}

// 6. 策略模式 - Resource ⭐⭐⭐⭐
Resource resource = new ClassPathResource("config.properties");
Resource resource2 = new FileSystemResource("/path/to/file");
```

### MyBatis框架

```java
// 1. 建造者模式 - SqlSessionFactoryBuilder ⭐⭐⭐⭐⭐
SqlSessionFactory factory = new SqlSessionFactoryBuilder()
    .build(inputStream);

// 2. 工厂模式 - SqlSessionFactory ⭐⭐⭐⭐⭐
SqlSession session = factory.openSession();

// 3. 代理模式 - Mapper接口 ⭐⭐⭐⭐⭐
UserMapper mapper = session.getMapper(UserMapper.class);
```

## 💡 最佳实践 ⭐⭐⭐⭐⭐

### 1. 何时使用设计模式

```java
// 不要过度设计
// 简单场景：
if (type.equals("A")) {
    return new ProductA();
} else {
    return new ProductB();
}

// 复杂场景才使用工厂模式
```

### 2. 组合优于继承

```java
// 不好：继承
class ColoredShape extends Shape { }

// 好：组合 ⭐⭐⭐⭐⭐
class Shape {
    private Color color;
}
```

### 3. 面向接口编程

```java
// 不好
ArrayList<String> list = new ArrayList<>();

// 好 ⭐⭐⭐⭐⭐
List<String> list = new ArrayList<>();
```

## 🎯 实战练习

1. 实现一个线程安全的单例模式
2. 使用策略模式实现多种排序算法
3. 使用装饰器模式增强功能
4. 使用观察者模式实现事件系统

## 📚 下一步

学习完设计模式后，继续学习：
- [单元测试](./单元测试.md)
- [Spring核心](../04-Spring生态/Spring核心.md)

