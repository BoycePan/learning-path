# Java多线程与并发编程

## 📌 学习目标

- 理解线程的概念和生命周期
- 掌握多线程创建和使用
- 理解线程同步和锁机制
- 掌握Java并发工具类
- 了解线程池的使用

## ⭐ 核心概念

- **进程**：程序的一次执行，系统资源分配的基本单位
- **线程**：进程内的执行单元，CPU调度的基本单位 ⭐⭐⭐⭐⭐
- **并发**：多个任务交替执行
- **并行**：多个任务同时执行

## 1. 线程创建 ⭐⭐⭐⭐⭐

### 方式1：继承Thread类

```java
/**
 * 继承Thread类 ⭐⭐⭐⭐
 */
class MyThread extends Thread {
    private String threadName;
    
    public MyThread(String name) {
        this.threadName = name;
    }
    
    @Override
    public void run() {
        // 线程执行的代码
        for (int i = 1; i <= 5; i++) {
            System.out.println(threadName + " - " + i);
            try {
                Thread.sleep(500);  // 休眠500毫秒
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class ThreadDemo1 {
    public static void main(String[] args) {
        // 创建线程对象
        MyThread thread1 = new MyThread("线程1");
        MyThread thread2 = new MyThread("线程2");
        
        // 启动线程 ⭐⭐⭐⭐⭐
        thread1.start();  // 注意：不是run()
        thread2.start();
        
        System.out.println("主线程继续执行");
    }
}
```

### 方式2：实现Runnable接口（推荐）⭐⭐⭐⭐⭐

```java
/**
 * 实现Runnable接口（推荐） ⭐⭐⭐⭐⭐
 * 优点：
 * 1. 避免Java单继承的限制
 * 2. 代码可以被多个线程共享
 * 3. 更符合面向对象思想
 */
class MyRunnable implements Runnable {
    private String taskName;
    
    public MyRunnable(String name) {
        this.taskName = name;
    }
    
    @Override
    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println(taskName + " - " + i + 
                " (线程：" + Thread.currentThread().getName() + ")");
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class RunnableDemo {
    public static void main(String[] args) {
        // 创建Runnable对象
        MyRunnable task = new MyRunnable("任务A");
        
        // 创建线程
        Thread thread1 = new Thread(task, "工作线程1");
        Thread thread2 = new Thread(task, "工作线程2");
        
        thread1.start();
        thread2.start();
    }
}
```

### 方式3：Lambda表达式（现代写法）⭐⭐⭐⭐⭐

```java
public class LambdaThreadDemo {
    public static void main(String[] args) {
        // Lambda方式创建线程（推荐） ⭐⭐⭐⭐⭐
        Thread thread1 = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                System.out.println("Lambda线程 - " + i);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        
        thread1.start();
        
        // 更简洁的写法
        new Thread(() -> System.out.println("简单任务")).start();
    }
}
```

### 方式4：Callable接口（有返回值）⭐⭐⭐⭐⭐

```java
import java.util.concurrent.*;

/**
 * Callable - 有返回值的线程 ⭐⭐⭐⭐⭐
 */
class MyCallable implements Callable<Integer> {
    private int number;
    
    public MyCallable(int number) {
        this.number = number;
    }
    
    @Override
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 1; i <= number; i++) {
            sum += i;
            Thread.sleep(100);
        }
        return sum;
    }
}

public class CallableDemo {
    public static void main(String[] args) {
        // 创建Callable任务
        MyCallable task1 = new MyCallable(100);
        MyCallable task2 = new MyCallable(50);
        
        // 创建FutureTask
        FutureTask<Integer> future1 = new FutureTask<>(task1);
        FutureTask<Integer> future2 = new FutureTask<>(task2);
        
        // 启动线程
        new Thread(future1).start();
        new Thread(future2).start();
        
        try {
            // 获取返回结果（会阻塞） ⭐⭐⭐⭐⭐
            Integer result1 = future1.get();
            Integer result2 = future2.get();
            
            System.out.println("任务1结果：" + result1);
            System.out.println("任务2结果：" + result2);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }
}
```

## 2. 线程状态与控制 ⭐⭐⭐⭐⭐

### 线程生命周期

```
新建(NEW)
   ↓ start()
就绪(RUNNABLE) ←→ 运行(RUNNING)
   ↓ sleep/wait/join
阻塞(BLOCKED/WAITING/TIMED_WAITING)
   ↓ 执行完成
死亡(TERMINATED)
```

### 线程常用方法

```java
public class ThreadMethodsDemo {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                System.out.println("子线程 - " + i);
                try {
                    Thread.sleep(1000);  // 休眠1秒 ⭐⭐⭐⭐⭐
                } catch (InterruptedException e) {
                    System.out.println("线程被中断");
                    return;
                }
            }
        });
        
        // 设置线程名称 ⭐⭐⭐⭐
        thread.setName("工作线程");
        
        // 设置优先级（1-10，默认5） ⭐⭐⭐
        thread.setPriority(Thread.MAX_PRIORITY);
        
        // 设置为守护线程 ⭐⭐⭐⭐
        thread.setDaemon(true);  // 必须在start()之前调用
        
        thread.start();
        
        // 获取当前线程 ⭐⭐⭐⭐⭐
        Thread currentThread = Thread.currentThread();
        System.out.println("当前线程：" + currentThread.getName());
        
        // 等待线程结束 ⭐⭐⭐⭐⭐
        thread.join();  // 主线程等待子线程结束
        
        // 检查线程状态 ⭐⭐⭐⭐
        System.out.println("线程是否存活：" + thread.isAlive());
        System.out.println("线程状态：" + thread.getState());
        
        // 中断线程 ⭐⭐⭐⭐
        // thread.interrupt();
    }
}
```

## 3. 线程同步 ⭐⭐⭐⭐⭐

### synchronized关键字 ⭐⭐⭐⭐⭐

```java
/**
 * 线程安全问题示例：银行账户
 */
class BankAccount {
    private int balance = 1000;
    
    // 方式1：同步方法 ⭐⭐⭐⭐⭐
    public synchronized void withdraw(int amount) {
        if (balance >= amount) {
            System.out.println(Thread.currentThread().getName() + 
                " 准备取款：" + amount);
            balance -= amount;
            System.out.println(Thread.currentThread().getName() + 
                " 取款成功，余额：" + balance);
        } else {
            System.out.println(Thread.currentThread().getName() + 
                " 余额不足");
        }
    }
    
    // 方式2：同步代码块 ⭐⭐⭐⭐⭐
    public void deposit(int amount) {
        synchronized (this) {
            balance += amount;
            System.out.println(Thread.currentThread().getName() + 
                " 存款：" + amount + "，余额：" + balance);
        }
    }
    
    public int getBalance() {
        return balance;
    }
}

public class SynchronizedDemo {
    public static void main(String[] args) {
        BankAccount account = new BankAccount();
        
        // 创建多个线程同时取款
        Runnable task = () -> {
            for (int i = 0; i < 3; i++) {
                account.withdraw(200);
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        
        Thread t1 = new Thread(task, "张三");
        Thread t2 = new Thread(task, "李四");
        Thread t3 = new Thread(task, "王五");
        
        t1.start();
        t2.start();
        t3.start();
    }
}
```

### Lock接口（推荐）⭐⭐⭐⭐⭐

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 使用Lock接口 ⭐⭐⭐⭐⭐
 * 优点：
 * 1. 可以尝试获取锁
 * 2. 可以设置超时
 * 3. 可以中断
 * 4. 更灵活
 */
class TicketOffice {
    private int tickets = 100;
    private Lock lock = new ReentrantLock();  // 可重入锁
    
    public void sellTicket() {
        lock.lock();  // 获取锁
        try {
            if (tickets > 0) {
                System.out.println(Thread.currentThread().getName() + 
                    " 售出第 " + tickets + " 张票");
                tickets--;
            }
        } finally {
            lock.unlock();  // 释放锁（必须在finally中） ⭐⭐⭐⭐⭐
        }
    }
    
    // 尝试获取锁 ⭐⭐⭐⭐
    public void tryLock() {
        if (lock.tryLock()) {
            try {
                System.out.println(Thread.currentThread().getName() + 
                    " 获取到锁");
                // 执行业务逻辑
            } finally {
                lock.unlock();
            }
        } else {
            System.out.println(Thread.currentThread().getName() + 
                " 未获取到锁");
        }
    }
}

public class LockDemo {
    public static void main(String[] args) {
        TicketOffice office = new TicketOffice();
        
        // 创建多个售票窗口
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> {
                for (int j = 0; j < 25; j++) {
                    office.sellTicket();
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }, "窗口" + i).start();
        }
    }
}
```

## 4. 线程通信 ⭐⭐⭐⭐⭐

### wait()和notify() ⭐⭐⭐⭐

```java
/**
 * 生产者-消费者模式 ⭐⭐⭐⭐⭐
 */
class SharedResource {
    private int product = 0;
    private final int MAX = 10;
    
    // 生产
    public synchronized void produce() {
        while (product >= MAX) {
            try {
                System.out.println("仓库已满，生产者等待...");
                wait();  // 等待 ⭐⭐⭐⭐⭐
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        
        product++;
        System.out.println("生产者生产，当前数量：" + product);
        notifyAll();  // 唤醒所有等待线程 ⭐⭐⭐⭐⭐
    }
    
    // 消费
    public synchronized void consume() {
        while (product <= 0) {
            try {
                System.out.println("仓库为空，消费者等待...");
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        
        product--;
        System.out.println("消费者消费，当前数量：" + product);
        notifyAll();
    }
}

public class ProducerConsumerDemo {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();
        
        // 生产者线程
        new Thread(() -> {
            for (int i = 0; i < 20; i++) {
                resource.produce();
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "生产者").start();
        
        // 消费者线程
        new Thread(() -> {
            for (int i = 0; i < 20; i++) {
                resource.consume();
                try {
                    Thread.sleep(150);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "消费者").start();
    }
}
```

## 5. 线程池 ⭐⭐⭐⭐⭐

### Executors工具类

```java
import java.util.concurrent.*;

public class ThreadPoolDemo {
    public static void main(String[] args) {
        // 1. 固定大小线程池 ⭐⭐⭐⭐⭐
        ExecutorService fixedPool = Executors.newFixedThreadPool(3);
        
        // 2. 缓存线程池 ⭐⭐⭐⭐
        ExecutorService cachedPool = Executors.newCachedThreadPool();
        
        // 3. 单线程池 ⭐⭐⭐
        ExecutorService singlePool = Executors.newSingleThreadExecutor();
        
        // 4. 定时任务线程池 ⭐⭐⭐⭐
        ScheduledExecutorService scheduledPool = 
            Executors.newScheduledThreadPool(2);
        
        // 使用线程池执行任务 ⭐⭐⭐⭐⭐
        for (int i = 1; i <= 10; i++) {
            final int taskId = i;
            fixedPool.execute(() -> {
                System.out.println("任务" + taskId + " 由 " + 
                    Thread.currentThread().getName() + " 执行");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
        
        // 提交有返回值的任务 ⭐⭐⭐⭐⭐
        Future<Integer> future = fixedPool.submit(() -> {
            int sum = 0;
            for (int i = 1; i <= 100; i++) {
                sum += i;
            }
            return sum;
        });
        
        try {
            Integer result = future.get();
            System.out.println("计算结果：" + result);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
        
        // 定时任务 ⭐⭐⭐⭐
        scheduledPool.schedule(() -> {
            System.out.println("3秒后执行的任务");
        }, 3, TimeUnit.SECONDS);
        
        // 周期性任务 ⭐⭐⭐⭐
        scheduledPool.scheduleAtFixedRate(() -> {
            System.out.println("每2秒执行一次：" + 
                System.currentTimeMillis());
        }, 0, 2, TimeUnit.SECONDS);
        
        // 关闭线程池 ⭐⭐⭐⭐⭐
        // fixedPool.shutdown();  // 等待任务完成后关闭
        // fixedPool.shutdownNow();  // 立即关闭
    }
}
```

### 自定义线程池（推荐）⭐⭐⭐⭐⭐

```java
import java.util.concurrent.*;

public class CustomThreadPool {
    public static void main(String[] args) {
        /**
         * 自定义线程池（阿里巴巴规范推荐） ⭐⭐⭐⭐⭐
         * 参数说明：
         * corePoolSize: 核心线程数
         * maximumPoolSize: 最大线程数
         * keepAliveTime: 空闲线程存活时间
         * unit: 时间单位
         * workQueue: 任务队列
         * threadFactory: 线程工厂
         * handler: 拒绝策略
         */
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            5,                          // 核心线程数
            10,                         // 最大线程数
            60,                         // 空闲线程存活时间
            TimeUnit.SECONDS,           // 时间单位
            new ArrayBlockingQueue<>(100),  // 任务队列
            Executors.defaultThreadFactory(),  // 线程工厂
            new ThreadPoolExecutor.CallerRunsPolicy()  // 拒绝策略
        );
        
        // 提交任务
        for (int i = 1; i <= 20; i++) {
            final int taskId = i;
            executor.execute(() -> {
                System.out.println("任务" + taskId + " 执行中...");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
        
        // 监控线程池状态 ⭐⭐⭐⭐
        System.out.println("核心线程数：" + executor.getCorePoolSize());
        System.out.println("最大线程数：" + executor.getMaximumPoolSize());
        System.out.println("当前线程数：" + executor.getPoolSize());
        System.out.println("活动线程数：" + executor.getActiveCount());
        System.out.println("任务总数：" + executor.getTaskCount());
        System.out.println("完成任务数：" + executor.getCompletedTaskCount());
        
        // 关闭线程池
        executor.shutdown();
    }
}
```

## 6. 并发工具类 ⭐⭐⭐⭐⭐

### CountDownLatch（倒计时器）⭐⭐⭐⭐

```java
import java.util.concurrent.CountDownLatch;

public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        int playerCount = 5;
        CountDownLatch latch = new CountDownLatch(playerCount);
        
        // 5个玩家准备
        for (int i = 1; i <= playerCount; i++) {
            final int playerId = i;
            new Thread(() -> {
                System.out.println("玩家" + playerId + "准备中...");
                try {
                    Thread.sleep((long) (Math.random() * 3000));
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("玩家" + playerId + "已准备");
                latch.countDown();  // 计数减1
            }).start();
        }
        
        System.out.println("等待所有玩家准备...");
        latch.await();  // 等待计数变为0
        System.out.println("所有玩家准备完毕，游戏开始！");
    }
}
```

### CyclicBarrier（循环屏障）⭐⭐⭐⭐

```java
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierDemo {
    public static void main(String[] args) {
        int parties = 3;
        
        CyclicBarrier barrier = new CyclicBarrier(parties, () -> {
            System.out.println("所有线程都到达屏障，开始下一阶段！\n");
        });
        
        for (int i = 1; i <= parties; i++) {
            final int id = i;
            new Thread(() -> {
                try {
                    System.out.println("线程" + id + "完成阶段1");
                    barrier.await();  // 等待其他线程
                    
                    System.out.println("线程" + id + "完成阶段2");
                    barrier.await();
                    
                    System.out.println("线程" + id + "全部完成");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

### Semaphore（信号量）⭐⭐⭐⭐

```java
import java.util.concurrent.Semaphore;

public class SemaphoreDemo {
    public static void main(String[] args) {
        // 3个许可证（3个停车位）
        Semaphore semaphore = new Semaphore(3);
        
        // 10辆车
        for (int i = 1; i <= 10; i++) {
            final int carId = i;
            new Thread(() -> {
                try {
                    System.out.println("车" + carId + "到达停车场");
                    semaphore.acquire();  // 获取许可
                    System.out.println("车" + carId + "进入停车位");
                    Thread.sleep(2000);  // 停车2秒
                    System.out.println("车" + carId + "离开停车位");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release();  // 释放许可
                }
            }).start();
        }
    }
}
```

## 💡 重点总结

### 线程创建方式对比 ⭐⭐⭐⭐⭐

| 方式 | 优点 | 缺点 | 推荐度 |
|------|------|------|--------|
| 继承Thread | 简单直观 | 单继承限制 | ⭐⭐⭐ |
| 实现Runnable | 避免单继承，代码复用 | 无返回值 | ⭐⭐⭐⭐⭐ |
| 实现Callable | 有返回值 | 稍复杂 | ⭐⭐⭐⭐⭐ |
| Lambda | 简洁 | - | ⭐⭐⭐⭐⭐ |
| 线程池 | 资源复用，性能好 | - | ⭐⭐⭐⭐⭐ |

### 同步方式对比 ⭐⭐⭐⭐⭐

| 方式 | 特点 | 使用场景 |
|------|------|---------|
| synchronized | 简单，自动释放锁 | 简单同步 |
| Lock | 灵活，功能强大 | 复杂同步 ⭐⭐⭐⭐⭐ |
| volatile | 轻量级，可见性 | 标志位 |
| Atomic类 | 原子操作 | 计数器 |

### 最佳实践 ⭐⭐⭐⭐⭐

1. **优先使用线程池** - 避免频繁创建销毁线程
2. **使用Lock代替synchronized** - 更灵活可控
3. **避免死锁** - 按顺序获取锁
4. **线程安全的集合** - 使用ConcurrentHashMap等
5. **合理设置线程池参数** - 根据业务特点调整

## 🎯 练习建议

1. 实现一个多线程下载器
2. 模拟12306抢票系统
3. 实现生产者-消费者模式
4. 设计一个线程池监控系统

## 📚 下一步

学习完多线程并发后，继续学习 [IO与NIO](./IO与NIO.md)

