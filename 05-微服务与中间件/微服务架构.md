# 微服务架构设计

## 📌 学习目标

- 理解微服务架构核心思想
- 掌握微服务设计原则
- 了解常见微服务模式
- 理解服务治理

## ⭐ 微服务核心概念

- **服务拆分** ⭐⭐⭐⭐⭐
- **服务通信** ⭐⭐⭐⭐⭐
- **服务治理** ⭐⭐⭐⭐⭐
- **分布式事务** ⭐⭐⭐⭐⭐
- **链路追踪** ⭐⭐⭐⭐⭐

## 1. 微服务架构演进

### 单体架构 vs 微服务架构

```
单体架构：
├── 所有功能在一个应用
├── 代码耦合度高
├── 部署简单
└── 难以扩展

微服务架构：
├── 功能拆分为独立服务
├── 服务独立部署
├── 易于扩展
└── 复杂度高
```

## 2. 服务拆分原则 ⭐⭐⭐⭐⭐

### 拆分策略

```
1. 按业务领域拆分（DDD）⭐⭐⭐⭐⭐
   - 用户服务
   - 订单服务
   - 商品服务
   - 支付服务

2. 按功能模块拆分 ⭐⭐⭐⭐
   - 认证服务
   - 通知服务
   - 文件服务

3. 按数据拆分 ⭐⭐⭐⭐
   - 每个服务独立数据库
   - 避免跨服务事务
```

## 3. 服务间通信 ⭐⭐⭐⭐⭐

### 同步通信（REST/RPC）

```java
/**
 * RESTful API ⭐⭐⭐⭐⭐
 */
@FeignClient("user-service")
public interface UserClient {
    @GetMapping("/users/{id}")
    User getById(@PathVariable Long id);
}

/**
 * gRPC（高性能）⭐⭐⭐⭐
 * - Protocol Buffers
 * - 双向流
 * - 性能优于REST
 */
```

### 异步通信（消息队列）

```
优点：
- 解耦
- 削峰填谷
- 异步处理

常用MQ：
- RocketMQ ⭐⭐⭐⭐⭐（推荐）
- Kafka ⭐⭐⭐⭐⭐
- RabbitMQ ⭐⭐⭐⭐
```

## 4. 分布式事务 ⭐⭐⭐⭐⭐

### Seata AT模式

```java
/**
 * 自动补偿 ⭐⭐⭐⭐⭐
 */
@GlobalTransactional
public void createOrder(Order order) {
    // 本地事务
    orderMapper.insert(order);
    // 远程调用
    stockClient.deduct(order.getProductId());
    accountClient.deduct(order.getUserId(), order.getAmount());
}
```

### Saga模式

```
长事务场景：
订单 → 库存 → 账户 → 积分
  ↓      ↓      ↓      ↓
回滚  回滚   回滚   回滚
```

## 💡 最佳实践

1. **服务粒度适中** - 不要过度拆分
2. **独立数据库** - 避免共享数据库
3. **熔断降级** - 防止雪崩
4. **链路追踪** - 快速定位问题
5. **服务监控** - 实时掌握状态

## 📚 下一步

继续学习 [消息队列](./消息队列.md)

