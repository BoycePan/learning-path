# 消息队列（MQ）

## 📌 学习目标

- 理解消息队列应用场景
- 掌握RocketMQ使用
- 了解Kafka基础
- 理解消息可靠性保证

## ⭐ 消息队列核心概念

- **异步解耦** ⭐⭐⭐⭐⭐
- **削峰填谷** ⭐⭐⭐⭐⭐
- **消息可靠性** ⭐⭐⭐⭐⭐
- **顺序消息** ⭐⭐⭐⭐
- **事务消息** ⭐⭐⭐⭐⭐

## 1. RocketMQ快速开始 ⭐⭐⭐⭐⭐

### Maven依赖

```xml
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-spring-boot-starter</artifactId>
    <version>2.2.3</version>
</dependency>
```

### 配置

```yaml
# application.yml
rocketmq:
  name-server: localhost:9876
  producer:
    group: my-producer-group
    send-message-timeout: 3000
```

### 生产者

```java
/**
 * 发送消息 ⭐⭐⭐⭐⭐
 */
@Service
public class ProducerService {
    
    @Autowired
    private RocketMQTemplate rocketMQTemplate;
    
    /**
     * 同步发送
     */
    public void sendSync(String topic, String message) {
        SendResult result = rocketMQTemplate.syncSend(topic, message);
        System.out.println("发送结果：" + result.getSendStatus());
    }
    
    /**
     * 异步发送
     */
    public void sendAsync(String topic, String message) {
        rocketMQTemplate.asyncSend(topic, message, new SendCallback() {
            @Override
            public void onSuccess(SendResult result) {
                System.out.println("发送成功");
            }
            
            @Override
            public void onException(Throwable e) {
                System.out.println("发送失败：" + e.getMessage());
            }
        });
    }
    
    /**
     * 单向发送（不关心结果）
     */
    public void sendOneWay(String topic, String message) {
        rocketMQTemplate.sendOneWay(topic, message);
    }
}
```

### 消费者

```java
/**
 * 消费消息 ⭐⭐⭐⭐⭐
 */
@Component
@RocketMQMessageListener(
    topic = "test-topic",
    consumerGroup = "my-consumer-group"
)
public class MessageConsumer implements RocketMQListener<String> {
    
    @Override
    public void onMessage(String message) {
        System.out.println("收到消息：" + message);
        // 处理业务逻辑
    }
}
```

## 2. 应用场景 ⭐⭐⭐⭐⭐

### 异步处理

```java
/**
 * 用户注册 - 异步发送邮件/短信 ⭐⭐⭐⭐⭐
 */
@Service
public class UserService {
    
    @Autowired
    private RocketMQTemplate rocketMQTemplate;
    
    public void register(User user) {
        // 1. 保存用户
        userMapper.insert(user);
        
        // 2. 异步发送欢迎邮件
        rocketMQTemplate.asyncSend("email-topic", user.getEmail());
        
        // 3. 异步发送短信
        rocketMQTemplate.asyncSend("sms-topic", user.getPhone());
        
        // 不用等待邮件、短信发送完成
    }
}
```

### 流量削峰

```java
/**
 * 秒杀场景 - 削峰填谷 ⭐⭐⭐⭐⭐
 */
@Service
public class SeckillService {
    
    @Autowired
    private RocketMQTemplate rocketMQTemplate;
    
    public void seckill(Long userId, Long productId) {
        // 先将请求放入消息队列
        SeckillMessage msg = new SeckillMessage(userId, productId);
        rocketMQTemplate.syncSend("seckill-topic", msg);
        
        // 异步处理，避免数据库瞬间压力过大
    }
}

@Component
@RocketMQMessageListener(
    topic = "seckill-topic",
    consumerGroup = "seckill-consumer"
)
public class SeckillConsumer implements RocketMQListener<SeckillMessage> {
    
    @Override
    public void onMessage(SeckillMessage message) {
        // 慢慢处理秒杀请求
        processSeckill(message.getUserId(), message.getProductId());
    }
}
```

## 3. 消息可靠性 ⭐⭐⭐⭐⭐

### 生产者重试

```java
/**
 * 发送失败自动重试 ⭐⭐⭐⭐⭐
 */
rocketMQTemplate.syncSend(
    "topic",
    message,
    3000,  // 超时时间
    3      // 重试次数
);
```

### 消费者ACK

```java
/**
 * 消费确认 ⭐⭐⭐⭐⭐
 */
@Override
public void onMessage(String message) {
    try {
        // 处理消息
        processMessage(message);
        // 成功则自动ACK
    } catch (Exception e) {
        // 失败则重试
        throw new RuntimeException("处理失败", e);
    }
}
```

## 4. Kafka基础 ⭐⭐⭐⭐⭐

### 特点

```
高吞吐量：百万级TPS
分布式：天然支持集群
持久化：消息持久化到磁盘
顺序性：分区内有序

适用场景：
- 日志收集
- 流式处理
- 大数据场景
```

### 基本使用

```java
/**
 * Kafka生产者 ⭐⭐⭐⭐
 */
@Service
public class KafkaProducerService {
    
    @Autowired
    private KafkaTemplate<String, String> kafkaTemplate;
    
    public void send(String topic, String message) {
        kafkaTemplate.send(topic, message);
    }
}

/**
 * Kafka消费者 ⭐⭐⭐⭐
 */
@Component
public class KafkaConsumerService {
    
    @KafkaListener(topics = "test-topic", groupId = "my-group")
    public void consume(String message) {
        System.out.println("收到消息：" + message);
    }
}
```

## 💡 MQ选型对比

| 特性 | RocketMQ | Kafka | RabbitMQ |
|------|---------|-------|----------|
| 吞吐量 | 10万+ | 100万+ | 万级 |
| 时效性 | ms级 | ms级 | us级 |
| 可用性 | 高 | 高 | 高 |
| 功能 | 丰富 | 简单 | 丰富 |
| 推荐场景 | 通用 ⭐⭐⭐⭐⭐ | 大数据 | 小规模 |

## 🎯 练习建议

1. 搭建RocketMQ环境
2. 实现生产者和消费者
3. 实现订单异步处理
4. 实现秒杀削峰

## 📚 下一步

继续学习 [分布式技术](./分布式技术.md)

