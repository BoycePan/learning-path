# 服务监控与链路追踪

## 📌 学习目标

- 理解监控的重要性
- 掌握Prometheus+Grafana
- 了解链路追踪原理
- 熟悉Skywalking/Zipkin
- 掌握日志收集

## ⭐ 核心内容

- **Prometheus** ⭐⭐⭐⭐⭐
- **Grafana** ⭐⭐⭐⭐⭐
- **Skywalking** ⭐⭐⭐⭐⭐
- **ELK日志** ⭐⭐⭐⭐
- **告警** ⭐⭐⭐⭐

## 1. 监控体系 ⭐⭐⭐⭐⭐

### 监控层次

```
应用监控：JVM、接口性能、业务指标 ⭐⭐⭐⭐⭐
中间件监控：MySQL、Redis、MQ
系统监控：CPU、内存、磁盘、网络
链路追踪：分布式调用链 ⭐⭐⭐⭐⭐
日志监控：错误日志、业务日志 ⭐⭐⭐⭐⭐
```

### 监控指标

```
QPS：每秒请求数
RT：响应时间
错误率：失败请求比例
可用性：服务可用时间比例
```

## 2. Prometheus ⭐⭐⭐⭐⭐

### Spring Boot集成

```xml
<!-- Maven依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>
```

### 配置

```yaml
# application.yml
management:
  endpoints:
    web:
      exposure:
        include: '*'  # 暴露所有端点
  endpoint:
    health:
      show-details: always
    prometheus:
      enabled: true
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
```

### 自定义指标 ⭐⭐⭐⭐⭐

```java
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;

@Service
public class UserService {
    
    private final Counter userCreatedCounter;
    private final Timer userQueryTimer;
    
    public UserService(MeterRegistry registry) {
        // 计数器 ⭐⭐⭐⭐⭐
        this.userCreatedCounter = Counter.builder("user.created")
            .description("用户创建数量")
            .tag("type", "register")
            .register(registry);
        
        // 计时器 ⭐⭐⭐⭐⭐
        this.userQueryTimer = Timer.builder("user.query")
            .description("用户查询耗时")
            .register(registry);
    }
    
    public void createUser(User user) {
        // 业务逻辑
        userRepository.save(user);
        
        // 增加计数
        userCreatedCounter.increment();
    }
    
    public User findById(Long id) {
        // 记录耗时 ⭐⭐⭐⭐⭐
        return userQueryTimer.record(() -> {
            return userRepository.findById(id).orElse(null);
        });
    }
}
```

### Prometheus配置

```yaml
# prometheus.yml
global:
  scrape_interval: 15s  # 抓取间隔

scrape_configs:
  - job_name: 'spring-boot-app'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets: ['localhost:8080']
```

### 常用PromQL ⭐⭐⭐⭐⭐

```promql
# HTTP请求总数
http_server_requests_seconds_count

# 平均响应时间
rate(http_server_requests_seconds_sum[5m]) / rate(http_server_requests_seconds_count[5m])

# QPS
rate(http_server_requests_seconds_count[1m])

# 错误率
rate(http_server_requests_seconds_count{status=~"5.."}[5m]) / rate(http_server_requests_seconds_count[5m])

# JVM内存使用
jvm_memory_used_bytes{area="heap"}

# CPU使用率
process_cpu_usage
```

## 3. Grafana ⭐⭐⭐⭐⭐

### 安装

```bash
# Docker方式
docker run -d \
  --name=grafana \
  -p 3000:3000 \
  grafana/grafana
```

### 配置数据源

```
1. 访问 http://localhost:3000
2. 默认账号：admin/admin
3. Configuration -> Data Sources -> Add data source
4. 选择Prometheus
5. URL: http://prometheus:9090
6. Save & Test
```

### 常用面板

```
JVM监控面板：4701
Spring Boot监控：11378
MySQL监控：7362
Redis监控：11835
```

## 4. Skywalking ⭐⭐⭐⭐⭐

### 什么是链路追踪？

```
分布式系统中，一个请求可能经过多个服务
链路追踪可以：
1. 追踪请求路径
2. 分析性能瓶颈
3. 定位错误来源
```

### Spring Boot集成

```xml
<!-- 无需添加依赖，使用Agent方式 -->
```

### 启动应用

```bash
# 下载Skywalking Agent
wget https://archive.apache.org/dist/skywalking/java-agent/8.16.0/apache-skywalking-java-agent-8.16.0.tgz
tar -zxvf apache-skywalking-java-agent-8.16.0.tgz

# 启动应用 ⭐⭐⭐⭐⭐
java -javaagent:/path/to/skywalking-agent/skywalking-agent.jar \
  -Dskywalking.agent.service_name=my-app \
  -Dskywalking.collector.backend_service=localhost:11800 \
  -jar myapp.jar
```

### 自定义Trace ⭐⭐⭐⭐

```java
import org.apache.skywalking.apm.toolkit.trace.Trace;
import org.apache.skywalking.apm.toolkit.trace.TraceContext;

@Service
public class UserService {
    
    // 自定义Trace ⭐⭐⭐⭐⭐
    @Trace
    public User findById(Long id) {
        // 添加Tag
        TraceContext.putCorrelation("userId", String.valueOf(id));
        
        return userRepository.findById(id).orElse(null);
    }
}
```

## 5. Zipkin ⭐⭐⭐⭐

### Spring Cloud集成

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-zipkin</artifactId>
</dependency>
```

### 配置

```yaml
spring:
  zipkin:
    base-url: http://localhost:9411
  sleuth:
    sampler:
      probability: 1.0  # 采样率100%
```

## 6. ELK日志收集 ⭐⭐⭐⭐

### Logback配置

```xml
<!-- logback-spring.xml -->
<configuration>
    <appender name="LOGSTASH" class="net.logstash.logback.appender.LogstashTcpSocketAppender">
        <destination>localhost:5000</destination>
        <encoder class="net.logstash.logback.encoder.LogstashEncoder">
            <customFields>{"app":"my-app"}</customFields>
        </encoder>
    </appender>
    
    <root level="INFO">
        <appender-ref ref="LOGSTASH"/>
    </root>
</configuration>
```

### Docker Compose部署ELK

```yaml
version: '3'
services:
  elasticsearch:
    image: elasticsearch:8.11.0
    environment:
      - discovery.type=single-node
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    ports:
      - "9200:9200"
  
  logstash:
    image: logstash:8.11.0
    ports:
      - "5000:5000"
    volumes:
      - ./logstash.conf:/usr/share/logstash/pipeline/logstash.conf
  
  kibana:
    image: kibana:8.11.0
    ports:
      - "5601:5601"
    environment:
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
```

## 7. 告警 ⭐⭐⭐⭐

### Prometheus告警规则

```yaml
# alert.rules.yml
groups:
  - name: example
    rules:
      # 服务宕机告警 ⭐⭐⭐⭐⭐
      - alert: ServiceDown
        expr: up == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "服务{{ $labels.instance }}宕机"
      
      # 高错误率告警 ⭐⭐⭐⭐⭐
      - alert: HighErrorRate
        expr: rate(http_server_requests_seconds_count{status=~"5.."}[5m]) > 0.05
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "错误率过高"
      
      # 高响应时间告警
      - alert: HighResponseTime
        expr: histogram_quantile(0.95, rate(http_server_requests_seconds_bucket[5m])) > 1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "95分位响应时间超过1秒"
```

### 钉钉告警

```java
@Component
public class DingTalkAlertService {
    
    private final RestTemplate restTemplate;
    private final String webhookUrl = "https://oapi.dingtalk.com/robot/send?access_token=xxx";
    
    public void sendAlert(String message) {
        DingTalkMessage msg = new DingTalkMessage();
        msg.setMsgtype("text");
        msg.setText(new Text(message));
        
        restTemplate.postForObject(webhookUrl, msg, String.class);
    }
}
```

## 8. 完整监控方案 ⭐⭐⭐⭐⭐

### Spring Boot应用配置

```yaml
# application.yml
spring:
  application:
    name: my-app
  
  # Zipkin链路追踪
  zipkin:
    base-url: http://zipkin:9411
  sleuth:
    sampler:
      probability: 1.0

# Actuator监控
management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    health:
      show-details: always
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
      env: ${spring.profiles.active}

# 日志
logging:
  level:
    root: INFO
    com.example: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
```

### Docker Compose完整方案

```yaml
version: '3'
services:
  # 应用
  app:
    image: my-app:1.0
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
  
  # Prometheus
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
  
  # Grafana
  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
  
  # Skywalking OAP
  skywalking-oap:
    image: apache/skywalking-oap-server:9.5.0
    ports:
      - "11800:11800"
      - "12800:12800"
  
  # Skywalking UI
  skywalking-ui:
    image: apache/skywalking-ui:9.5.0
    ports:
      - "8081:8080"
    environment:
      - SW_OAP_ADDRESS=http://skywalking-oap:12800
```

## 💡 最佳实践 ⭐⭐⭐⭐⭐

### 1. 监控指标设计

```java
// 业务指标
Counter orderCounter = Counter.builder("order.created")
    .tag("type", "online")
    .register(registry);

// 性能指标
Timer paymentTimer = Timer.builder("payment.process")
    .register(registry);

// 资源指标
Gauge.builder("cache.size", cache, Cache::size)
    .register(registry);
```

### 2. 日志规范

```java
// 使用结构化日志
log.info("用户登录成功, userId={}, ip={}", userId, ip);

// 不要打印敏感信息
log.info("用户信息: {}", user.toString());  // 确保toString不包含密码

// 异常日志
log.error("处理订单失败, orderId={}", orderId, e);
```

### 3. 告警策略

```
P0（紧急）：服务宕机、数据丢失 - 立即处理
P1（重要）：高错误率、性能下降 - 30分钟内处理
P2（一般）：资源使用率高 - 2小时内处理
P3（提示）：优化建议 - 工作时间处理
```

## 🎯 实战练习

1. 搭建Prometheus+Grafana监控系统
2. 集成Skywalking链路追踪
3. 配置告警规则
4. 搭建ELK日志系统

## 📚 下一步

学习完监控后，继续学习：
- [Kubernetes入门](./Kubernetes入门.md)
- [项目实战](../06-项目实战/项目实战.md)

