# 分布式技术

## 📌 学习目标

- 理解分布式系统核心概念
- 掌握分布式锁
- 了解分布式ID生成
- 理解分布式缓存
- 了解分布式存储

## ⭐ 分布式核心问题

- **分布式锁** ⭐⭐⭐⭐⭐
- **分布式ID** ⭐⭐⭐⭐⭐
- **分布式缓存** ⭐⭐⭐⭐⭐
- **分布式事务** ⭐⭐⭐⭐⭐
- **CAP理论** ⭐⭐⭐⭐⭐

## 1. 分布式锁 ⭐⭐⭐⭐⭐

### Redis实现

```java
/**
 * Redis分布式锁 ⭐⭐⭐⭐⭐
 */
@Service
public class RedisLockService {

    @Autowired
    private StringRedisTemplate redisTemplate;

    /**
     * 获取锁
     */
    public boolean tryLock(String key, String value, long timeout) {
        Boolean success = redisTemplate.opsForValue()
            .setIfAbsent(key, value, timeout, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(success);
    }

    /**
     * 释放锁（Lua脚本保证原子性）
     */
    public boolean unlock(String key, String value) {
        String script =
            "if redis.call('get', KEYS[1]) == ARGV[1] then " +
            "return redis.call('del', KEYS[1]) else return 0 end";

        Long result = redisTemplate.execute(
            new DefaultRedisScript<>(script, Long.class),
            Collections.singletonList(key),
            value
        );

        return Long.valueOf(1).equals(result);
    }
}
```

### Redisson实现（推荐）

```java
/**
 * Redisson分布式锁 ⭐⭐⭐⭐⭐
 */
@Service
public class RedissonLockService {

    @Autowired
    private RedissonClient redissonClient;

    public void executeWithLock(String lockKey, Runnable task) {
        RLock lock = redissonClient.getLock(lockKey);

        try {
            // 尝试获取锁，最多等待10秒，锁30秒后自动释放
            if (lock.tryLock(10, 30, TimeUnit.SECONDS)) {
                task.run();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}
```

## 2. 分布式ID ⭐⭐⭐⭐⭐

### 雪花算法（Snowflake）

```java
/**
 * 雪花算法ID生成器 ⭐⭐⭐⭐⭐
 *
 * 64位Long型ID：
 * 1位符号位 + 41位时间戳 + 10位机器ID + 12位序列号
 */
public class SnowflakeIdGenerator {
    private final long workerId;
    private final long datacenterId;
    private long sequence = 0L;
    private long lastTimestamp = -1L;

    public SnowflakeIdGenerator(long workerId, long datacenterId) {
        this.workerId = workerId;
        this.datacenterId = datacenterId;
    }

    public synchronized long nextId() {
        long timestamp = System.currentTimeMillis();

        // 时钟回拨
        if (timestamp < lastTimestamp) {
            throw new RuntimeException("时钟回拨异常");
        }

        // 同一毫秒内
        if (timestamp == lastTimestamp) {
            sequence = (sequence + 1) & 4095;  // 4095 = 2^12 - 1
            if (sequence == 0) {
                timestamp = tilNextMillis(lastTimestamp);
            }
        } else {
            sequence = 0L;
        }

        lastTimestamp = timestamp;

        return ((timestamp - 1609459200000L) << 22)  // 时间戳部分
            | (datacenterId << 17)                    // 数据中心ID
            | (workerId << 12)                        // 机器ID
            | sequence;                               // 序列号
    }

    private long tilNextMillis(long lastTimestamp) {
        long timestamp = System.currentTimeMillis();
        while (timestamp <= lastTimestamp) {
            timestamp = System.currentTimeMillis();
        }
        return timestamp;
    }
}
```

### 数据库自增ID

```sql
-- 优点：简单
-- 缺点：性能瓶颈、单点故障

CREATE TABLE id_generator (
    id BIGINT PRIMARY KEY AUTO_INCREMENT
) ENGINE=InnoDB;
```

### Redis生成ID

```java
/**
 * Redis自增ID ⭐⭐⭐⭐
 */
public long generateId(String key) {
    return redisTemplate.opsForValue().increment(key);
}
```

## 3. 分布式缓存 ⭐⭐⭐⭐⭐

### 缓存一致性

```java
/**
 * Cache Aside模式 ⭐⭐⭐⭐⭐
 */
@Service
public class UserCacheService {

    @Autowired
    private UserMapper userMapper;

    @Autowired
    private StringRedisTemplate redisTemplate;

    /**
     * 查询
     */
    public User getById(Long id) {
        String key = "user:" + id;

        // 1. 查缓存
        String json = redisTemplate.opsForValue().get(key);
        if (json != null) {
            return JSON.parseObject(json, User.class);
        }

        // 2. 查数据库
        User user = userMapper.selectById(id);

        // 3. 写缓存
        if (user != null) {
            redisTemplate.opsForValue().set(
                key,
                JSON.toJSONString(user),
                1,
                TimeUnit.HOURS
            );
        }

        return user;
    }

    /**
     * 更新（先更新数据库，再删除缓存）⭐⭐⭐⭐⭐
     */
    public void update(User user) {
        // 1. 更新数据库
        userMapper.updateById(user);

        // 2. 删除缓存
        String key = "user:" + user.getId();
        redisTemplate.delete(key);
    }
}
```

### 缓存穿透/击穿/雪崩

```java
/**
 * 缓存穿透：查询不存在的数据 ⭐⭐⭐⭐⭐
 * 解决：缓存空值、布隆过滤器
 */
public User getByIdWithBloomFilter(Long id) {
    // 布隆过滤器判断
    if (!bloomFilter.mightContain(id)) {
        return null;
    }

    // 正常查询流程
    return getById(id);
}

/**
 * 缓存击穿：热点key过期 ⭐⭐⭐⭐⭐
 * 解决：互斥锁、热点数据永不过期
 */
public User getByIdWithLock(Long id) {
    String key = "user:" + id;
    String lockKey = "lock:" + key;

    // 1. 查缓存
    String json = redisTemplate.opsForValue().get(key);
    if (json != null) {
        return JSON.parseObject(json, User.class);
    }

    // 2. 获取锁
    Boolean locked = redisTemplate.opsForValue()
        .setIfAbsent(lockKey, "1", 10, TimeUnit.SECONDS);

    if (Boolean.TRUE.equals(locked)) {
        try {
            // 3. 双重检查
            json = redisTemplate.opsForValue().get(key);
            if (json != null) {
                return JSON.parseObject(json, User.class);
            }

            // 4. 查数据库
            User user = userMapper.selectById(id);

            // 5. 写缓存
            if (user != null) {
                redisTemplate.opsForValue().set(
                    key,
                    JSON.toJSONString(user),
                    1,
                    TimeUnit.HOURS
                );
            }

            return user;
        } finally {
            redisTemplate.delete(lockKey);
        }
    } else {
        // 等待后重试
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return getByIdWithLock(id);
    }
}

/**
 * 缓存雪崩：大量key同时过期 ⭐⭐⭐⭐⭐
 * 解决：过期时间加随机值
 */
public void setWithRandomExpire(String key, String value) {
    long expire = 3600 + ThreadLocalRandom.current().nextInt(600);
    redisTemplate.opsForValue().set(key, value, expire, TimeUnit.SECONDS);
}
```

## 4. CAP理论 ⭐⭐⭐⭐⭐

```
CAP定理：分布式系统只能同时满足两个

C（Consistency）- 一致性
A（Availability）- 可用性
P（Partition Tolerance）- 分区容错性

常见组合：
- CP：强一致性（如ZooKeeper、HBase）
- AP：高可用性（如Eureka、Cassandra）
- CA：单机系统（如MySQL单机）

微服务通常选择AP，保证可用性
通过最终一致性保证数据一致
```

## 💡 重点总结

### 分布式技术选型

| 技术       | 工具      | 推荐度     |
| ---------- | --------- | ---------- |
| 分布式锁   | Redisson  | ⭐⭐⭐⭐⭐ |
| 分布式ID   | Snowflake | ⭐⭐⭐⭐⭐ |
| 分布式缓存 | Redis     | ⭐⭐⭐⭐⭐ |
| 分布式事务 | Seata     | ⭐⭐⭐⭐⭐ |
| 配置中心   | Nacos     | ⭐⭐⭐⭐⭐ |
| 注册中心   | Nacos     | ⭐⭐⭐⭐⭐ |

## 🎯 练习建议

1. 实现Redis分布式锁
2. 实现雪花算法ID生成
3. 实现三级缓存架构
4. 理解CAP理论

## 📚 下一步

完成微服务与中间件学习后，进入 [项目实战](../06-项目实战/)
